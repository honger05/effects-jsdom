{
"success": true,
"data": [
{
"id": "575e70ef4a43c1cb159ffe25",
"author_id": "4f19795e817ae4105c01cc1f",
"tab": "share",
"content": "<div class=\"markdown-text\"><p>JSConf China 已经五年了，这五年来我们一直秉持着给国内JS开发者带来高质量的技术会议的宗旨。\n5年来有超过1700位开发者参加过我们的活动，也有超过80位讲师给我们带来了精彩的分享。\n今年的JSConf China 又来了，今年九月我们将在南京举办宁JS。\n我们也希望今年依然能够给大家带来一个值回票价的技术大会。\n现在购票通道已经开通，早鸟5分钟内售完 :)\n<a href=\"http://www.bagevent.com/event/58905\">http://www.bagevent.com/event/58905</a></p>\n<p>感谢几位发起人，发起这个国内最大的JavaScript开发者大会。\n也感谢他们一直以来对组织活动的支持。\n<img src=\"https://cloud.githubusercontent.com/assets/914595/16001382/3ca6953a-3184-11e6-8f52-d22e37eed623.png\" alt=\"image\"></p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/914595/16001470/b949f8f2-3184-11e6-80df-6867d2bc5551.png\" alt=\"image\"></p>\n<p>JavaScript everywhere!</p>\n<p>:)</p>\n</div>",
"title": "中国最大的JavaScript开发者大会JSConf China 2016即宁JS 售票啦！",
"last_reply_at": "2016-07-29T09:56:20.458Z",
"good": false,
"top": true,
"reply_count": 50,
"visit_count": 11328,
"create_at": "2016-06-13T08:38:07.230Z",
"author": {
"loginname": "xeodou",
"avatar_url": "//gravatar.com/avatar/dbefd0e4d332a8d252c0251075262e8d?s=48"
}
},
{
"id": "5796d0272d740f7c26637e9f",
"author_id": "542bff0c10ab5791322617c7",
"tab": "share",
"content": "<div class=\"markdown-text\"><h1>TL; DR</h1>\n<blockquote>\n<p>来了很多小伙伴</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/7.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>Juliet 介绍活动流程</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/6.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>Berwin 分享Koa原理和实践</p>\n</blockquote>\n<p>下载Slides: <a href=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/koa_berwin_20160723.pdf\">koa_berwin_20160723</a></p>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/2.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>Hain 分享人工智能和聊天机器人</p>\n</blockquote>\n<p>下载Slides: <a href=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/AI_Chatbot_hain_20160723.pdf\">AI_Chatbot_hain_20160723</a></p>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/4.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>二楼看客</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/9.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>撸串</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/8.pic.jpg\" width=\"500\" />\n<h2>号召捐助</h2>\n<p>NodeParty一直努力推广优秀的Node.js/JavaScript技术，始终秉持着拥抱变化、创新和竭尽分享的旨意。13次活动共输出了32个主题分享，并延伸了微信公众号和多个微信群，运营NodeParty有多名志愿者，野狗科技、科技寺和珠峰培训也大力支持。为了能更好的发展NodeParty并从Web应用开发和移动应用开发基础上，将主题分享范围扩大到虚拟现实技术、人工智能技术、物联网技术，需要更多支持，如果您参加过NodeParty，认同我们的工作，请伸出援助之手。</p>\n<blockquote>\n<p>微信扫一扫</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/donate-rmb100.png\" width=\"300\" />\n<h2>加入 BJ NodeJS Club</h2>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/poster-20160616/poster_M.png\" width=\"600\" /></div>",
"title": "北京 7.23 NodeParty 总结",
"last_reply_at": "2016-07-27T06:53:12.384Z",
"good": false,
"top": true,
"reply_count": 0,
"visit_count": 1480,
"create_at": "2016-07-26T02:51:19.955Z",
"author": {
"loginname": "Samurais",
"avatar_url": "https://avatars.githubusercontent.com/u/3538629?v=3&s=120"
}
},
{
"id": "579d748e85dba6b12ac58561",
"author_id": "542940f12ca9451e1bf3c24c",
"tab": "job",
"content": "<div class=\"markdown-text\"><p>4年php经验，正在学习nodejs！我的微信huochai2016</p>\n</div>",
"title": "求nodejs职位",
"last_reply_at": "2016-08-02T01:52:16.050Z",
"good": false,
"top": false,
"reply_count": 6,
"visit_count": 407,
"create_at": "2016-07-31T03:46:22.601Z",
"author": {
"loginname": "huaiguoguo",
"avatar_url": "https://avatars.githubusercontent.com/u/1888094?v=3&s=120"
}
},
{
"id": "579febd99f22cae71c65429b",
"author_id": "560b957d272b724e5efefd92",
"tab": "ask",
"content": "<div class=\"markdown-text\"><p>因为这个应用面对的是国内用户，所以最好是国内的部署服务提供商。</p>\n<p>大家有什么好推荐的吗？😃</p>\n</div>",
"title": "最近开发了一个 koa + mongo 的应用，问问大家平时都用国内哪家的部署服务？",
"last_reply_at": "2016-08-02T01:39:36.951Z",
"good": false,
"top": false,
"reply_count": 1,
"visit_count": 61,
"create_at": "2016-08-02T00:39:53.715Z",
"author": {
"loginname": "xiekw2010",
"avatar_url": "https://avatars.githubusercontent.com/u/1814071?v=3&s=120"
}
},
{
"id": "57980b28f0d4b46026ba5519",
"author_id": "5507e4e053ad0efa46bc502c",
"tab": "job",
"content": "<div class=\"markdown-text\"><p>加入我们，待遇从优，装备齐全，一条大裤衩，一双人字拖，一把AK47，多劳多得，只要大干一票， 在大都市买楼不再是梦想，干两票，跻身上流社会，直接与范爷、大幂幂等大牌对话不再是距离。别再犹豫了，给你一片海域，换你一生奇迹! 诚招js猿，以下是通往你人生巅峰的列车：</p>\n<p>职位要求：\n1.熟悉mac开发环境；\n2.精通nodejs，bootstrap，HTML5，熟悉nw.js；\n3.熟悉JavaScript，对流行的JavaScript框架有实际使用经验；\n4.熟悉手机端和PC端web实现的差异，有移动平台web前端开发经验，了解移动互联网产品和行业，有在Android,iOS等平台下HTML5+CSS+JavaScript（或移动JS框架）开发经验者优先考虑；\n5.良好的沟通能力和团队协作精神，对移动互联网行业有浓厚的兴趣，有较强的研究能力和学习能力。</p>\n<p>电话：010-62978515\n邮箱：zhangdp2005@163.com\n地址：北京海淀区上地三街嘉华大厦c座</p>\n</div>",
"title": "诚聘node开发工程师——北京",
"last_reply_at": "2016-08-02T01:18:58.086Z",
"good": false,
"top": false,
"reply_count": 2,
"visit_count": 670,
"create_at": "2016-07-27T01:15:20.835Z",
"author": {
"loginname": "zhangdp2005",
"avatar_url": "https://avatars.githubusercontent.com/u/11517062?v=3&s=120"
}
},
{
"id": "57812e64ee5f048d54f90800",
"author_id": "535cbb096b02f25e580123e9",
"tab": "share",
"content": "<div class=\"markdown-text\"><h1>Electron</h1>\n<h3>introduction</h3>\n<h4>1.1 Electron是什么？</h4>\n<p>引用官网的一句话：\n<strong>Build cross platform desktop apps with JavaScript, HTML, and CSS</strong></p>\n<h4>1.2 诞生</h4>\n<p><strong>技术背景：</strong></p>\n<p>JavaScript近几年的全领域发展，个人理解JavaScript是思想对java的前进，从<strong>compile once,run everywhere</strong>转变为<strong>code once,run everywhere</strong>，由于JavaScript本身的是一门解释性的脚本语言，这让它逐渐的成为全宇宙使用最广泛的语言，没有之一。</p>\n<p>JavaScript只是JavaScript，在浏览器中，它操作DOM和BOM，在服务器端它操作FileSystem，HTTP，所以在任何环境，他都可以执行，即使是在几M的内存环境，这点对物联网来说很重要。</p>\n<p><strong>调用需求：</strong></p>\n<p>传统的PC软件开发成本太高，和网络的兴起，让传统的开发逐渐被在线系统吊打，高成本必然逐渐的走下坡路，这是符合经济上发展的趋势，但是由于性能的问题，不管是VR还是直播，需要采集视频，音频，网卡信息，而这些模块大多数还是C、C++来获取</p>\n<p><strong>传统局限：</strong>\n在浏览器里，Web页面通常运行在一个沙盒环境里，它不能访问本地的资源。\n比如在Web页面里，调用本地GUI是不允许的，因为在Web页面里管理本地GUI资源是非常危险的而且非常容易导致资源泄露。如果你想在Web页面进行GUI操作，该Web页面的渲染进程必须通过和主进程通信来请求主进程处理这些操作。</p>\n<h4>1.3 Electron的组成</h4>\n<p><strong>1.软件成分：</strong>\nElectron: 1.2.6\tNode: 6.1.0\tChromium: 51.0.2704.106\tV8: 5.1.281.65\n（各方面都足够新，ES和TS都可以撸代码）</p>\n<p><strong>2.工具支持：（官方提供）</strong>\n功能上支持：\nAutomatic updates\nNative menus &amp; notifications\nApp crash reporting\nDebugging &amp; profiling\nWindows installers</p>\n<p>写代码&amp;部署：\nElectron Packager — Package your apps<br>\nElectron Builder — Deploy your apps\nSpectron — Test your apps Devtron —\nDebug your apps Electron\nPrebuilt — Install Electron<br>\nMenubar — Create menubar apps</p>\n<p><strong>3.萌新的学习材料：</strong>\n官网提供一个比较全面的DEMO，包括常规的系统级别操作，通信，截图，调用PDF等例子\nAPI支持多语言，已经翻译好，个别翻译会让读者懵逼\nAPI中有不少例子，但是不是很全，个人觉得是用的人比较少，有可能会有填坑的情况</p>\n<p><strong>4.成熟产品：</strong>\n官网上列举了很多，个人觉得做的比较好的是：VSC和白鹭的IDE\n（由于白鹭的IDE主要作者是我师哥，之前跟他学习了一下，整个下午都是在卧槽！！的状态）</p>\n<h3>quick start</h3>\n<h4>2.1 搭建开发环境</h4>\n<p>1.官网是有个一个quick start的例子的，我推荐先下载demo点点看看，<a href>传送门</a></p>\n<p>2.下载官方的quick start的例子:</p>\n<pre class=\"prettyprint\"><code># Clone the Quick Start repository\n$ git clone https:&#x2F;&#x2F;github.com&#x2F;electron&#x2F;electron-quick-start\n\n# Go into the repository\n$ cd electron-quick-start\n\n# Install the dependencies and run\n$ npm install &amp;&amp; npm start\n</code></pre><p>但是如果有小伙伴没翻墙，被拦在的寡妇网内，npm install失败了，那就用下面这个办法吧\n（换了源也不好使的话）</p>\n<p>根据系统去淘宝的镜像上下载最新的Electron包，<a href>传送门</a></p>\n<p>我是windows,解压之后可以点击electron.exe就可以看到提示</p>\n<pre class=\"prettyprint\"><code>To run your app with Electron, execute the following command in your Console (or Terminal):\nC:\\Users\\carlos\\Desktop\\electron\\electron.exe path-to-your-app\n</code></pre><p>把工程的文件夹拖进来，或者执行cmd命令就可以看到效果了，我是觉得这里可以加到环境变量里，但是没完成功，留个小坑以后填</p>\n<p><strong>注意，Electron的Console.log()是输出到控制台的，所以当你concole一个东西看不到的时候，试试CMD启动</strong></p>\n<p>现在</p>\n<ul>\n<li>api √</li>\n<li>demo √</li>\n<li>quick-start √</li>\n<li>run environment√</li>\n<li>Hello world √</li>\n</ul>\n<p>恭喜你已经入坑了</p>\n<h3>First Electron</h3>\n<p>如果你是一个好学的同学，那你应该自己琢磨quick-start，如果你是懒癌晚期，那就继续听我逼逼</p>\n<h4>3.1 请建立以下目录</h4>\n<pre class=\"prettyprint\"><code>your-app\n- main.js\n- index.html\n- package.json\n</code></pre><h4>3.2 说明</h4>\n<p>package.json 的格式与Node的模块格式是一致的，可以引入依赖</p>\n<pre class=\"prettyprint\"><code>{\n &quot;name&quot;: &quot;electron-quick-start&quot;,\n &quot;version&quot;: &quot;1.0.0&quot;,\n &quot;description&quot;: &quot;A minimal Electron application&quot;,\n &quot;main&quot;: &quot;main.js&quot;\n}\n</code></pre><p><strong>这里要注意的是，现在的Electron已经不指定main.js做为入口了，在package.json中可以设置启动入口</strong></p>\n<p>main 就是你应用的启动脚本，该脚本将运行在主进程中,请保证你拖进Electron的文件夹下能找到这个文件</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;引入electron\nconst electron = require(&#x27;electron&#x27;);\n&#x2F;&#x2F;app控制整个Electron的声明周期\nconst app =electron.app;\n&#x2F;&#x2F;创建一个本地的窗口\nconst BrowserWindow = electron.BrowserWindow\n&#x2F;&#x2F;保持一个全局的窗口对象，可以不显示，如果没有这个对象，窗口点击关闭的时候，js对象会被gc干掉\nlet mainWindow;\n\nfunction createWindow(){\n mainWindow = new BrowserWindow({\n width: 800, \n height: 600\n })\n &#x2F;&#x2F;加载静态资源\n mainWindow.loadURL(&#x27;file:&#x2F;&#x2F;&#x27; + __dirname + &#x27;&#x2F;index.html&#x27;);\n\n mainWindow.on(&quot;closed&quot;,function(){\n mainWindow = null\n })\n}\n\n&#x2F;&#x2F;生命周期的函数定义\n&#x2F;&#x2F;这里好好看api http:&#x2F;&#x2F;electron.atom.io&#x2F;docs&#x2F;api&#x2F;app&#x2F;\napp.on(&quot;ready&quot;,createWindow)\n\napp.on(&#x27;window-all-closed&#x27;, function () {\n if (process.platform !== &#x27;darwin&#x27;) {\n app.quit()\n }\n})\n\napp.on(&#x27;activate&#x27;, function () {\n if (mainWindow === null) {\n createWindow()\n }\n})\n</code></pre><p>index.html做为静态资源被加载，可以引用一些mvvm，比如一会儿我会引入vue，也可以引入three.js</p>\n<pre class=\"prettyprint\"><code>&lt;!doctype html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;h1&gt;Hello world&lt;&#x2F;h1&gt;\n\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n</code></pre><h4>3.3.启动</h4>\n<p>拖拽文件夹到electron.exe中，就可以看到下面的效果</p>\n<p><img src=\"//dn-cnode.qbox.me/FrsUUhtzRJrNm5nxeC4oti5SovX_\" alt=\"electron1.jpg\"></p>\n<h4>3.4.搞点事</h4>\n<p>可以尝试一下，在package.json中添加依赖，或者在index.html中</p>\n<pre class=\"prettyprint\"><code>mainWindow = new BrowserWindow({\n width: 800, \n height: 600,\n frame: false\n})\n</code></pre><h3>API</h3>\n<h4>4.1 MENU &amp; 设置快捷键</h4>\n<p>引入menu有两种方法，写在HTMl里，或者写在main.js这样的文件里\n我个人喜欢后者，因为HTML说不定会别的地方会用，上来就报错不太好\n推荐阅读menu和menuiteam的官方API和例子\n<a href=\"http://electron.atom.io/docs/api/menu/\">http://electron.atom.io/docs/api/menu/</a>\n<a href=\"http://electron.atom.io/docs/api/menu-item/\">http://electron.atom.io/docs/api/menu-item/</a></p>\n<p>先看代码</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;引入menu\nlet Menu = electron.Menu;\n&#x2F;&#x2F;引入menuIteam\nlet MenuItem = electron.MenuItem\n&#x2F;&#x2F;创建一个menuIteam\nconst menuIteam_first = new MenuItem({\n\tlabel:&quot;Electron&quot;,\n\tsubmenu: [\n\t\t{\n \t&#x2F;&#x2F;需要通过cmd来启动\n\t\t\tlabel:&quot;show sth in cmd&quot;,\n\t\t\tclick(){\n\t\t\t\tconsole.log(&quot;clickLabel&quot;)\n\t\t\t}\n\t\t},\n\t\t{\n \t&#x2F;&#x2F;创建一个新的窗口\n\t\t\tlabel:&quot;new window&quot;,\n\t\t\taccelerator:&quot;CmdOrCtrl+N&quot;,\n\t\t\trole:&quot;&quot;,\n\t\t\tclick(){\n\t\t\t\tlet newwindow = new BrowserWindow({\n\t\t\t\t\twidth: 400, \n \t\t\t\theight: 300,\n\t\t\t\t\tresizable:false\n\t\t\t\t})\n\t\t\t\tnewwindow.loadURL(&#x27;file:&#x2F;&#x2F;&#x27; + __dirname + &#x27;&#x2F;source&#x2F;electron1.jpg&#x27;);\n\t\t\t\tnewwindow.on(&quot;closed&quot;,function(){\n\t\t\t\t\tnewwindow = null\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t\t{\n \t&#x2F;&#x2F;可以看到一个选中的选项\n\t\t\tlabel: &#x27;checked&#x27;, \n\t\t\ttype: &#x27;checkbox&#x27;, \n\t\t\tchecked: true\n\t\t},\n\t\t{\n \t&#x2F;&#x2F;所有menuIteam的label都可以有submenu\n\t\t\tlabel: &#x27;Gender&#x27;, \n\t\t\tsubmenu:[\n\t\t\t\t{\n\t\t\t\t\tlabel:&quot;male&quot;,\n\t\t\t\t\ttype:&quot;radio&quot;,\n\t\t\t\t\tchecked:true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel:&quot;female&quot;,\n\t\t\t\t\ttype:&quot;radio&quot;,\n\t\t\t\t\tchecked:false\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel:&quot;computer&quot;,\n\t\t\t\t\ttype:&quot;radio&quot;,\n\t\t\t\t\tchecked:true\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\n\t\t{\n \t&#x2F;&#x2F;只写role可以调用一些默认的设置，比如这个是全屏\n\t\t\trole: &#x27;togglefullscreen&#x27;\n\t\t},\n\t\t{\n \t&#x2F;&#x2F;accelerator是定义快捷键，click可以按自己需要写\n\t\t\tlabel: &#x27;Developer Tools&#x27;,\n\t\t\taccelerator: process.platform === &#x27;darwin&#x27; ? &#x27;CmdOrCtrl+I&#x27; : &#x27;CmdOrCtrl+I&#x27;,\n\t\t\tclick(item, focusedWindow) {\n\t\t\tif (focusedWindow)\n\t\t\t\tfocusedWindow.webContents.toggleDevTools();\n\t\t\t}\n\t\t},\n\t\t{\t\n \t&#x2F;&#x2F;可以调用role默认的同时重写一些需要的内容\n\t\t\tlabel:&quot;GOODBYE&quot;,\n\t\t\trole:&quot;quit&quot;,\n\t\t\taccelerator:&quot;CmdOrCtrl+Q&quot;\n\t\t}\n\t]\n});\n</code></pre><p>解释一下：\n创建menu很简单三步就能说清楚\n1、创建一个menu对象，定义好label的叫什么，往里面塞menuIteam\n2、定义你的menuIteam，可以用role简化，也可以不写role，自己写click()函数\n3、挂在到你的窗口上</p>\n<p><strong>注意，窗口的宽和高是整个视窗的，间距边框和工具栏才是html的宽和高，要是不想麻烦，give up这部分，用html写好然后调用系统的js接口吧</strong></p>\n<h4>4.2 最小化图标</h4>\n<p>QQ平时是可以最小化到右下角的，用Electron来实现很容易\n但是请确认你已经读懂了Menu部分</p>\n<p>还是推荐先看API\n<a href=\"http://electron.atom.io/docs/api/tray\">http://electron.atom.io/docs/api/tray</a></p>\n<p>然后看代码：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;引入Tray\nlet Tray = electron.Tray;\nlet tray = null;\n\nfunction createWindow(){\n\tmainWindow = new BrowserWindow({\n\t\twidth: 800, \n\t\theight: 600\n\t})\n\t&#x2F;&#x2F;加载静态资源\n\tmainWindow.loadURL(&#x27;file:&#x2F;&#x2F;&#x27; + __dirname + &#x27;&#x2F;index.html&#x27;);\n\n\tlet image = nativeImage.createFromPath(&#x27;&#x2F;source&#x2F;electron1.jpg&#x27;);\n\n\ttray = new Tray(image);\n\n\tconst contextMenu = Menu.buildFromTemplate([\n\t\t\n\t\t{\n\t\t\tlabel:&quot;show&quot;,\n\t\t\tclick(){\n\t\t\t\tmainWindow.show()\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tlabel:&quot;Exit&quot;,\n\t\t\trole:&quot;quit&quot;\n\t\t}\n\t]);\n\t&#x2F;&#x2F; tray.setToolTip(&#x27;This is my application.&#x27;)\n\ttray.setContextMenu(contextMenu)\n\n\tmainWindow.on(&quot;closed&quot;,function(){\n\t\tmainWindow = null\n\t})\n\n}\n</code></pre><p>创建一个右下角小图标很简单，两步即可\n1、声明一个全局的tray对象，然后在你创建主窗口的初始化函数中，给它一个默认图标\n2、创建一个menu，这个步骤跟刚才一样，记得绑定到tray上</p>\n<p>注意一点：tray的图片需要nativeImage格式，具体什么是nativeImage<a href>看这里</a>,如果你的图标type Error了，那么可以使用electron提供的一个转换函数把i的图片转换一下</p>\n<pre class=\"prettyprint\"><code>const nativeImage = electron.nativeImage;\n</code></pre><h4>4.3 ipcMain</h4>\n<p>ipcMain是用来让mainWindow和创建的window们传递数据</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;main.js\nipcMain.on(&#x27;asynchronous-message&#x27;, (event, arg) =&gt; {\n console.log(arg); &#x2F;&#x2F; prints &quot;ping&quot;\n event.sender.send(&#x27;asynchronous-reply&#x27;, &#x27;pong&#x27;);\n});\n\nipcMain.on(&#x27;synchronous-message&#x27;, (event, arg) =&gt; {\n console.log(arg); &#x2F;&#x2F; prints &quot;ping&quot;\n event.returnValue = &#x27;pong&#x27;;\n});\n\n</code></pre><pre class=\"prettyprint\"><code>&lt;script&gt;\n const {ipcRenderer} = require(&#x27;electron&#x27;);\n\n console.log(ipcRenderer.sendSync(&#x27;synchronous-message&#x27;, &#x27;ping&#x27;)); \n\n ipcRenderer.on(&#x27;asynchronous-reply&#x27;, (event, arg) =&gt; {\n console.log(arg); &#x2F;&#x2F; prints &quot;pong&quot;\n });\n\n ipcRenderer.send(&#x27;asynchronous-message&#x27;, &#x27;ping&#x27;);\n&lt;&#x2F;script&gt;\n</code></pre><p><img src=\"//dn-cnode.qbox.me/Fr8ZiDjawra0bXpaLjw3qag_q_h_\" alt=\"electron2.jpg\"></p>\n<p>解释一下：\n1.在主窗口中定义ipcMain，注册一些同步or异步事件来处理收到的事件\n2.在需要发消息的窗口，发送消息\n3.如果是异步的，在发送消息的窗口，定义接收信息事件</p>\n<h4>4.4 桌面捕获</h4>\n<p>占位，困</p>\n<h3>End</h3>\n<p>就使用结果来看，视频，音频等流媒体的获取我还在研究，其他的模块Electron的表现还是相当不错的，至少我想到的桌面开发需求还是都有的。即使没有，咱们还有node嘛，多走一层就是了。</p>\n<p>需求场景我觉得还是蛮多的，比如ERP，CMS都这种通过网站打开的在线办公系统比较依赖网站，用这个封装一下，可以免去很多初级用户（交互定义上的）的使用风险</p>\n<p>强交互的场景还是比较需要桌面版的，比如Tower、钉钉这样的都有需求</p>\n<p>我建议程序员们现在可以上手玩，自己做一个集成软件，比如我接下来会将监控&amp;管理工程文件，md的一些文档的预览，发周报的脚本，爬虫等等集成到一起，做一个统一入口</p>\n<p><strong>欢迎各位指正&amp;交流</strong></p>\n<p><strong>杜绝无脑黑</strong></p>\n<p>推荐阅读\n<a href>官网的一篇demo的介绍</a></p>\n</div>",
"title": "Electron简介",
"last_reply_at": "2016-08-02T00:52:45.789Z",
"good": true,
"top": false,
"reply_count": 15,
"visit_count": 1735,
"create_at": "2016-07-09T17:03:32.535Z",
"author": {
"loginname": "CarlosRen",
"avatar_url": "https://avatars.githubusercontent.com/u/6012322?v=3&s=120"
}
},
{
"id": "579e341885dba6b12ac58583",
"author_id": "532a80b757287ed35700da1e",
"tab": "share",
"content": "<div class=\"markdown-text\"><h2>Javascript 定义</h2>\n<ul>\n<li>单线程</li>\n<li>异步 IO</li>\n<li>并发</li>\n<li>基于原型的面向对象</li>\n<li>脚本语言</li>\n</ul>\n<h2>Javascript 引擎与运行时环境</h2>\n<p>Javascript 引擎和运行时环境这两个概念很容易被弄混，但它俩真不是一个东西。Javascript 引擎做的事情是实现 ECMAScript 标准，解释（或编译） Javascript 代码；而运行环境是包括引擎并提供一些类库让 Javascript 代码能够在其上运行，例如 Chrome, Node。</p>\n<h2>为什么设计为单线程？</h2>\n<blockquote>\n<p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。\nJavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n摘自 <a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>\n</blockquote>\n<h2>单线程如何异步，如何并发？</h2>\n<p>我们知道，在一段程序代码中发起一个调用并等待直到调用返回结果再执行接下来的代码，这个调用对于这段程序来说是同步的；而发起一个调用后不用等待调用结果而直接执行后面的代码，这个调用对于这段程序来说就是异步的。</p>\n<p>异步意味着在主逻辑中被异步调用的代码和主逻辑继续执行的代码会同时执行，这其实是实现了并发。回想一下我们在 Java 或者其它多线程语言中是如何实现异步的，一般来说，要创建一个异步任务，我们通常会创建一个线程然后在线程中执行该任务，这个任务和创建它的线程就可以并发执行了。但 Javascript 单线程的特性显然和这异步、并发是有冲突的，那么为什么说 Javascript 支持异步，支持并发呢？</p>\n<p>其实理解起来也很简单，Javascript 本身并不是异步的，而 Javascript 程序是异步的。具体来说就是，Javascript 编写的代码自身运行于单线程中，当遇到 IO 调用，就把它丢给运行时环境处理，自身继续执行后面的代码，当 IO 调用有了结果，会将结果及回调放在一个队列里，Javascript 线程会在合适的时机将回调函数取出并执行。</p>\n<p>Javascript 程序的异步由其运行时环境提供，通过<code>event loop</code>实现异步编程，并提供并发支持。</p>\n<p>实现异步编程可以有很多种方式(<code>编程模型</code>)，想了解更多可以先看看<a href=\"http://www.jianshu.com/p/c4dc7866eb81\">这篇文章</a>。</p>\n<h2>Javascript 具体是如何工作的</h2>\n<p>单说<code>Javascript 是如何工作的</code>其实不太准确，应该说<code>Javascript 在其运行时环境上是如何工作的</code>才对，Node 和 Chrome 都是 Javascript 的运行时环境，它们使用相同的 JavaScript 引擎(V8)，都应用基于 <code>event loop</code> 的并发模型( Chrome 内核使用了 libevent 而 Node 则基于 libuv )，那么 Javascript 在这样的运行时环境下是如何工作的呢？</p>\n<p>是时候祭出这张图了\n<img src=\"http://img.blog.csdn.net/20160731235811549\" alt>￼</p>\n<blockquote>\n<p>此图来自Philip Roberts的演讲<a href=\"http://vimeo.com/96425312\">《Help, I’m stuck in an event-loop》</a></p>\n</blockquote>\n<p>这张图讲的是 Javascript 在浏览器中的工作原理，在 Node 中也差不多，很具有代表性。</p>\n<p><strong>看图说话</strong></p>\n<ol>\n<li>V8 在编译执行 Javascript 代码过程中会生成堆( heap ) 和栈 ( stack )，heap 存放的程序运行过程中产生的一些对象，stack 是 Javascript 执行栈，程序代码会根据调用关系被压入栈中执行；</li>\n<li>当遇到调用 WebAPIs（IO 或者 定时器）时，浏览器会响应调用并直接返回，stack 继续执行剩余 Javascript 代码；</li>\n<li>当 WebAPIs 调用完成，会将相应的回调与结果依次放入 <code>callback queue</code> 中；</li>\n<li>当执行栈中如果没有要执行的 Javascript 代码，则会通过 <code>event loop</code> 检查并取出 <code>callback queue</code> 中第一个回调函数，并执行它。</li>\n</ol>\n<p>这样，我们所编写的 Javascript 代码会在<code>执行引擎</code>的执行栈中以单线程的方式运行，而所有 IO 或定时任务会通过运行环境异步执行，并将执行结果放在 <code>callback queue</code> 中等待被调用，这就是所谓的单线程异步的工作原理，当然 Javascript 实际运行环境的实现会比这复杂一些，但基本原理就是这样；理解这个原理能够让我们更加清楚我们的每一段代码在运行环境中是如何执行的，有很多疑惑例如：程序代码中的多个回调会在什么时候被调用？为什么复杂的计算逻辑要使用 <code>setImmediate(function () { // 计算逻辑 }); 或 process.nextTick(function () { // 计算逻辑 });</code> 包起来？就容易理解了。</p>\n<h2>小结</h2>\n<p>本文主要解释了 Javascript 作为单线程语言，其程序是如何实现异步的，同时也大概讲解了 Javascript 在其运行时环境中的工作原理；在解惑的同时也带来了一些疑惑：</p>\n<ul>\n<li><code>setImmediate 和 process.nextTick</code> 的区别是什么？</li>\n<li>既然 Javascript 程序也是通过(运行时环境)底层的多线程实现异步，那跟多线程语言实现的异步有什么不同？</li>\n<li>为什么说基于 <code>Event loop</code> 实现异步编程模型的 <code>Node</code> 更适合 IO 密集型的应用，底层不都是多线程吗？</li>\n</ul>\n<p>这些问题也是我在做 Javascript 开发不同阶段中真真实实遇到的疑惑，通过自己一步一步的探索得到了一些解释，希望也能帮到正遇到这些疑惑的朋友们，如有问题，请指出。</p>\n<p>篇幅原因（才怪，因为懒）这些疑惑下一篇再来探讨。</p>\n<h2>参考</h2>\n<p><a href=\"http://blog.csdn.net/lin_credible/article/details/40143961\">朴灵评注-JavaScript 运行机制详解：再谈Event Loop</a>\n<a href=\"http://vimeo.com/96425312\">Help, I’m stuck in an event-loop</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\">并发模型与Event Loop</a>\n<a href=\"http://www.cnblogs.com/dolphinX/p/3475090.html\">关于node.js的误会</a>\n<a href=\"https://github.com/goddyZhao/GPosts/blob/master/javascript/%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E9%80%94%E5%BE%84%E8%83%BD%E5%A4%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JavaScript%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md\">通过什么途径能够深入了解JavaScript解析引擎是如何工作的？</a>\n<a href=\"https://cnodejs.org/topic/4f16442ccae1f4aa2700113b\">nodejs异步IO的实现</a></p>\n</div>",
"title": "Javascript 工作原理",
"last_reply_at": "2016-08-02T00:52:18.910Z",
"good": true,
"top": false,
"reply_count": 14,
"visit_count": 658,
"create_at": "2016-07-31T17:23:36.199Z",
"author": {
"loginname": "sweetvvck",
"avatar_url": "https://avatars.githubusercontent.com/u/3828494?v=3&s=120"
}
},
{
"id": "56a3c8f47ec020ed4b96b2cd",
"author_id": "556d9f40bf871b3962efb841",
"tab": "share",
"content": "<div class=\"markdown-text\"><p>本篇文章翻译自expressjs官方网站，源地址如下：<a href=\"http://expressjs.com/en/advanced/best-practice-performance.html\">express最佳实践</a> ,分别从dev角度和ops角度讨论了如何提升express应用的运行性能以及部署的最佳方式。</p>\n<p>欢迎访问<a href=\"http://jsmean.com/blog/post/56a3b2947b7d4ff930cc7475\">个人blog</a>查看本文内容。</p>\n<h3>针对开发者需要注意的问题</h3>\n<p>对于一个express应用我们，一般有以下的几种方法来提升应用的运行效率以及响应率。</p>\n<ol>\n<li>使用gzip压缩</li>\n<li>代码中不要使用同步函数</li>\n<li>使用中间件处理静态文件</li>\n<li>合理的日志处理方法</li>\n<li>正确的处理异常</li>\n</ol>\n<p>以下我们将分别对于每个子项目进行展开分析。</p>\n<h5>1.使用gzip压缩</h5>\n<p>使用gzip压缩可以显著的减小响应包的大小，这样就提升了客户端的响应速度，我们可以通过使用compression中间件来处理gzip的压缩。对于一个大量用户的网站，最佳的方式是在反向代理端设置压缩方式。可以参考我的另一篇文章专门介绍如何配置nginx来处理压缩和静态文件的。这样的话，我们在代码端就不用再调用compression中间件了，nginx会帮助我们完成此项工作。</p>\n<pre class=\"prettyprint\"><code>var compression = require(&#x27;compression&#x27;);\nvar express = require(&#x27;express&#x27;);\nvar app = express();\napp.use(compression());\n</code></pre><h5>2.不要使用同步函数</h5>\n<p>我们知道node主进程为一个单一线程的程序(异步处理为多线程)。主线程中如果我们调用一些同步函数，而且这些同步函数执行时间较长，则会影响后续程序的执行等待时间。针对web端则表现为其他用户的访问延迟增大。所以在生产环境中，即便一个返回几个微妙的程序，对于大量用户的访问都将会造成积累效应。所以尽量使用异步的方式去编写代码。</p>\n<p>如果使用Node.js 4.0+ 或者 io.js 2.1.0+,可以使用参数 --trace-sync-io 去打印针对同步函数的告警信息。</p>\n<h5>3.使用中间件来处理静态文件</h5>\n<p>我们有时候调用res.sendFile()来处理静态文件，但是不要在生产环境中使用，这样会针对每个请求都去读该文件，不仅没有效率而且影响整体的性能，可以通过使用serve-static中间件来处理文件，但是我们推荐的更好的方式是使用nginx等反向代理静态文件。</p>\n<h5>4.合理的日志处理方式</h5>\n<p>我们在开发环境中有时候会通过console.log或者console.err标记一些点或者调试输出内容.但是这些函数都是同步的，将输出内容输出到终端与输出到文件的道理是相同，所以在生产环境中不要这样做。除非不得已去讲输出传递到另一个程序中的时候。我们可以使用debug模块来实现输出，该模块将判断环境变量是否是开发环境，执行debug输出，保证你的程序的异步处理。对于记录日志的话，大家可以参考一篇针对日志系统的比较文章<a href=\"https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/?_ga=1.264536015.1196661681.1453521338\">比较Winston和Bunyan</a>。</p>\n<h5>5. 正确的处理异常</h5>\n<p>首先对于node程序来说，一旦遇到不可处理的异常，则整个进程就会down掉，如果我们配置了pm2或者forever这样的进程管理工具的话，他会帮助我们去处理我们的程序失败自启动。</p>\n<p>对于代码中异常的处理我们一般的使用方法：</p>\n<ol>\n<li>使用try-catch</li>\n<li>使用<a href=\"http://expressjs.com/en/advanced/best-practice-performance.html#promises\">promises</a></li>\n</ol>\n<p>这里有一篇文章比较详细的介绍了如何构建健壮的程序来处理错误异常，供参考<a href=\"https://strongloop.com/strongblog/robust-node-applications-error-handling/?_ga=1.24936442.1196661681.1453521338\">链接地址</a></p>\n<p>不要使用uncaughtException来处理所有的异常，虽然一定程度上可以导致你的程序不中断，但是程序将包含不稳定的代码持续的运行下去，这样的代码运行在线上可能造成的后果更加的严重，甚至有过建议将该错误处理方式移除node内核。</p>\n<p>也不要使用domains来处理错误，该模块已被标记为待移除模块。</p>\n<p>使用try-catch是一种比较简单的错误处理方式，比如下面的代码：</p>\n<pre class=\"prettyprint\"><code>app.get(&#x27;&#x2F;search&#x27;, function (req, res) {\n &#x2F;&#x2F; Simulating async operation\n setImmediate(function () {\n var jsonStr = req.query.params;\n try {\n var jsonObj = JSON.parse(jsonStr);\n res.send(&#x27;Success&#x27;);\n } catch (e) {\n res.status(400).send(&#x27;Invalid JSON string&#x27;);\n }\n });\n});\n</code></pre><p>但是我们知道try-catch只能应用在同步的代码上面，对于异步的代码处理我们无法使用该方式进行处理。对于异步代码的异常处理我们可以使用promises来完成。只需要增加一个catch()方法就可以捕获流程中的整个代码块的异常。</p>\n<pre class=\"prettyprint\"><code>app.get(&#x27;&#x2F;&#x27;, function (req, res, next) {\n &#x2F;&#x2F; do some sync stuff\n queryDb()\n .then(function (data) {\n &#x2F;&#x2F; handle data\n return makeCsv(data)\n })\n .then(function (csv) {\n &#x2F;&#x2F; handle csv\n })\n .catch(next);\n});\n\napp.use(function (err, req, res, next) {\n &#x2F;&#x2F; handle error\n});\n</code></pre><p>当然了，我们需要在每个代码块中都加入promises返回。更多的信息可以参考一下链接<a href=\"https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/?_ga=1.235763905.1196661681.1453521338\">Asynchronous Error Handling in Express with Promises, Generators and ES7</a>。</p>\n<h3>生产环境安装部署</h3>\n<p>以下我们讨论的是针对生产环境中express应用安装部署上需要注意的问题。</p>\n<ol>\n<li>设置NODE_ENV为“production”</li>\n<li>确保应用的自动重启</li>\n<li>将应用部署一个集群中</li>\n<li>缓存请求结果</li>\n<li>使用负载均衡</li>\n<li>使用反向代理</li>\n</ol>\n<h5>1. 设置运行环境变量</h5>\n<p>一般我们设置node环境变量有两种，分别是 development 和 production。设置环境变量为production将会使得express应用</p>\n<ol>\n<li>缓存视图模板</li>\n<li>缓存css文件</li>\n<li>生成更少的冗余错误信息</li>\n</ol>\n<p>另外如果大家感兴趣的话可以查看这篇文章<a href=\"http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/\">环境变量测试</a>，这里作者对于设置该变量前后做了一些性能上的对比，非常详细。</p>\n<p>如果我们使用upstart来管理应用的话我们需要配置文件中加入环境变量</p>\n<pre class=\"prettyprint\"><code># &#x2F;etc&#x2F;init&#x2F;env.conf\nenv NODE_ENV=production\n</code></pre><p>如果是使用systemd来管理的话，则修改配置文件如下：</p>\n<pre class=\"prettyprint\"><code># &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;myservice.service\nEnvironment=NODE_ENV=production\n</code></pre><h5>2.确保自启动</h5>\n<p>这里自启动不仅仅指的是如何在程序异常终止之后启动而且还要保证程序在操作系统重启之后能自启动。这里我们分别介绍下两种情况。</p>\n<ol>\n<li>使用一个进程管理器</li>\n</ol>\n<p>进程管理器一般可以帮助我们，获得进程的运行性能和资源的消耗，动态的修改配置提升性能，集群控制。这里我么推荐的一般可以使用strongloop process manager或者pm2还有forever，同样详细的参考如下链接<a href=\"http://strong-pm.io/compare/?_ga=1.20403576.1196661681.1453521338\">进程管理器比较</a>\n通过上述的比较我们可以看出，strongloop的进程管理器支持的特性更丰富一些，特别是查看cpu占用堆占用，集成操作系统脚本，远程管理集群等等。</p>\n<ol>\n<li>随系统启动的程序自启动</li>\n</ol>\n<p>随系统启动的程序，我们可以使用之前的进程管理器，forever应该是不支持的。其他的都可以生成对应的启动脚本，当操作系统启动的时候，进程管理器启动，并带动程序的启动。或者我们可以直接配置使用systemd等方式来管理进程的开机启动。\n我们这里简单的通过介绍systemd的方式来介绍如何设置程序的随系统启动。systemd是一个linux系统的服务管理器。一个systemd的配置文件被称作为unit file.以.service为后缀。</p>\n<pre class=\"prettyprint\"><code>[Unit]\nDescription=Awesome Express App\n\n[Service]\nType=simple\nExecStart=&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;projects&#x2F;myapp&#x2F;index.js\nWorkingDirectory=&#x2F;projects&#x2F;myapp\n\nUser=nobody\nGroup=nogroup\n\n# Environment variables:\nEnvironment=NODE_ENV=production\n\n# Allow many incoming connections\nLimitNOFILE=infinity\n\n# Allow core dumps for debugging\nLimitCORE=infinity\n\nStandardInput=null\nStandardOutput=syslog\nStandardError=syslog\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre><h5>3. 将app运行在一个集群中</h5>\n<p>在多核心处理上运行的应用，可以通过使用cluster模块启动多个实例运行在不同的处理器上。并在多个实例上实现“负载均衡”。\n<img src=\"http://expressjs.com/images/clustering.png\" alt=\"image\">\n但是对于不同的实例，由于内存空间的隔离，导致所有的程序对象都是本地的，无法实现共享，但是我们可以借助于redis这样的工具实现对象的共享。并且对于某个进程的终端不会影响其他进程的处理，只需要在编写代码的时候记录此次终端并生成一个新的实例即可。</p>\n<p>我们可以使用node的cluster模块（需要编写代码实现）或者是strongloop的进程管理器来处理，并且不需要修改代码。strongloop PM将根据cpu的数目自动的生成多个进程，并且可以手动调整该值。</p>\n<h5>4. 缓存请求</h5>\n<p>使用缓存，可以极大的提升响应速度，而不需要对于重复的请求做重复的操作。我们可以使用nginx<a href=\"https://serversforhackers.com/nginx-caching/\">缓存配置</a>来配置缓存</p>\n<h5>5. 使用负载均衡</h5>\n<p>单一的express进程服务，不管如何优化都无法达到一个很高的性能需求，特别是对于一个拥有很多用户的web应用。我们可以通过使用一个负载均衡器来完成应用的水平的扩展。比如使用nginx或者HAProxy来完成负载均衡。在使用负载均衡的时候，我们可能需要确保每一个请求关联相对应的会话ID落到同一个进程上。这里有一篇文章可以供参考，了解如何配置负载均衡<a href=\"http://socket.io/docs/using-multiple-nodes/\">socket.io配置负载均衡</a></p>\n<p>另外strongloop pm可以很好的与nginx配合设置负载均衡。</p>\n<h5>6. 反向代理服务</h5>\n<p>反向代理服务器一般设置在请求入口处，完成错误页面处理，压缩处理，缓存和静态文件处理，负载均衡操作等等。具体的可参考nginx或者HAProxy的配置来完成反向代理服务的搭建。</p>\n<p>PS: 个人网站 <a href=\"http://www.jsmean.com\">www.jsmean.com</a> 。基于mean stack 开发。主要是讨论一些js相关内容，欢迎大家访问</p>\n</div>",
"title": "Express 开发与部署最佳实践",
"last_reply_at": "2016-08-02T00:35:29.388Z",
"good": true,
"top": false,
"reply_count": 52,
"visit_count": 6423,
"create_at": "2016-01-23T18:39:48.809Z",
"author": {
"loginname": "zhangmingkai4315",
"avatar_url": "https://avatars.githubusercontent.com/u/8868334?v=3&s=120"
}
},
{
"id": "5785a43049e4faa95429c6f3",
"author_id": "5567cd27070e73ca2c4d922f",
"tab": "ask",
"content": "<div class=\"markdown-text\"><p>能不能有个轻便易用的图形验证码包啊，\nccap那个好难安装成功，对node版本也有限制，有什么别的好用的吗</p>\n</div>",
"title": "能不能有个轻便易用的图形验证码包啊",
"last_reply_at": "2016-08-02T00:08:09.147Z",
"good": false,
"top": false,
"reply_count": 14,
"visit_count": 797,
"create_at": "2016-07-13T02:15:12.033Z",
"author": {
"loginname": "xiashulin",
"avatar_url": "https://avatars.githubusercontent.com/u/11418033?v=3&s=120"
}
},
{
"id": "579e8e74da05b9e92af325ad",
"author_id": "50b5bc5d637ffa4155091236",
"tab": "ask",
"content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var swig = require(&#x27;swig&#x27;);\nvar template = swig.compileFile(&#x27;&#x2F;absolute&#x2F;path&#x2F;to&#x2F;template.html&#x27;);\nvar output = template({\n pagename: &#x27;awesome people&#x27;,\n authors: [&#x27;Paul&#x27;, &#x27;Jim&#x27;, &#x27;Jane&#x27;]\n});\n\n</code></pre></div>",
"title": "swig模板有人用吗？",
"last_reply_at": "2016-08-02T00:06:44.908Z",
"good": false,
"top": false,
"reply_count": 8,
"visit_count": 217,
"create_at": "2016-07-31T23:49:08.919Z",
"author": {
"loginname": "yakczh",
"avatar_url": "https://avatars.githubusercontent.com/u/6591466?v=3&s=120"
}
},
{
"id": "535601a20d7d0faf140303d8",
"author_id": "5333889a5432b1822f016b2d",
"content": "<div class=\"markdown-text\"><h1>通过 nodeclub 项目源码来讲解如何做一个 nodejs + express + mongodb 项目</h1>\n<hr>\n<h2>##1. About</h2>\n<ul>\n<li>1.1 <strong>what</strong>:\nnodeclub 是 <a href=\"http://cnodejs.org\">cnodejs.org</a> 的源码，CNode 算是一个基本的博客系统，包含文章发布， 关注，评论等功能。这些功能可以说是任何一个网站的基础。从 nodeclub 里可以学到什么？\n<ul>\n<li>1.基本的架构</li>\n<li>2.开发测试过程</li>\n<li>3.MVC 的设计</li>\n<li>4.middleware 的正确用法</li>\n<li>5.如何设计 Mongodb schema</li>\n<li>6.如何正确的使用 Mongoose</li>\n<li>7.如何实现一个标签系统</li>\n<li>8.plugins? services ?</li>\n<li>9.如何正确的使用 EJS helper</li>\n<li>10.到底该怎样写路由， restful？</li>\n<li>11.如何做基本的控制验证</li>\n<li>12.如何发邮件</li>\n<li>13.session</li>\n<li>14.GitHub 用户登录</li>\n<li>15.图片上传</li>\n<li>16.消息发送</li>\n</ul>\n</li>\n</ul>\n<p>除了 nodeclub 源码的学习笔记以外， 还会有一点最近捣鼓这一块的经验分享</p>\n<ul>\n<li>1.一个完整的消息订阅设计</li>\n<li>2.消息推送, socket + express 如何合作?</li>\n<li>3.包装 action</li>\n<li>4.蛋疼的异步回调如何处理</li>\n</ul>\n<p><a href=\"https://github.com/cnodejs/nodeclub\">nodeclub源码</a></p>\n<ul>\n<li>1.2 <strong>why</strong>:</li>\n</ul>\n<p>对于想用 nodejs + express + mongodb 来做网站技术基础的项目， nodeclub 可以说是很好的源码级指南，当然也是我的指南，这篇文章权当做个人学习 nodeclub 的学习笔记。</p>\n<ul>\n<li>1.3 <strong>who</strong></li>\n</ul>\n<pre class=\"prettyprint language-coffee\"><code>who = 一名本应该在写前端的但不知怎的一直在写后端的马脓 -&gt; \n [@echo](&#x2F;user&#x2F;echo) &#x27;github: https:&#x2F;&#x2F;github.com&#x2F;6174&#x27;\n [@echo](&#x2F;user&#x2F;echo) &#x27;weibo: http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2254313183&#x27;\n [@echo](&#x2F;user&#x2F;echo) &#x27;email: 57017125[@qq](&#x2F;user&#x2F;qq).com&#x27;\n [@echo](&#x2F;user&#x2F;echo) &#x27;ps: 一直在求后端partner中，有意者联系我&#x27; \n [@send](&#x2F;user&#x2F;send)()\n</code></pre><h2>2. nodeclub 中用到了哪些开源技术</h2>\n<hr>\n<ul>\n<li>\n<p>2.1 Node.js 项目一大优点就是有一个 <code>package.json</code>, 里边的 <code>dependencies</code> &amp; <code>devDependencies</code> 可以看到这个项目所有的依赖。 对于有经验的开发者来说， 看完 <code>package.json</code> 基本就能知道项目的架构是怎样。</p>\n</li>\n<li>\n<p>2.2 <strong>dependencies</strong></p>\n</li>\n</ul>\n<ul>\n<li><code>express</code>: 基础框架：</li>\n<li><code>mongodb</code>: 数据存储</li>\n<li><code>mongoose</code>: orm</li>\n<li><code>connect-mongo</code>: session （对于redis， 可以使用connect-redis）</li>\n<li><code>nodemailer</code>：邮件</li>\n<li><code>validator</code>：验证</li>\n<li><code>passport</code>，<code>passport-github</code>： passport，</li>\n<li><code>loader</code>: ejs-view-helper, 静态资源加载处理</li>\n<li>其他： <code>event-proxy</code>, <code>node-markdown</code>, <code>ndir</code></li>\n</ul>\n<ul>\n<li>2.3 <strong>devDependencies</strong></li>\n</ul>\n<ul>\n<li>测试框架：<code>mocha</code>, <code>should</code></li>\n<li>运行： <code>forever</code></li>\n<li>请求模拟: <code>supertest</code></li>\n</ul>\n<ul>\n<li>2.4 nodeclub 以 express + mongodb + mongoose 作为基本框架, 典型的 MVC 应用</li>\n</ul>\n<ul>\n<li><strong>Model</strong>: 对应mongoose orm， models目录</li>\n<li><strong>view</strong>： ejs模板， views目录</li>\n<li><strong>controler</strong>：express middleware , contollers目录</li>\n</ul>\n<ul>\n<li>2.5 目录结构：</li>\n</ul>\n<pre class=\"prettyprint\"><code>- common&#x2F;\n- controllers&#x2F;\n- libs&#x2F;\n# express中间件， 基本的auth， session 验证\n- middlewares&#x2F;\n- models&#x2F;\n#消息， 邮件服务\n- services&#x2F;\n- plugins&#x2F;\n#可以看做是对model处理的加工库\n- proxy&#x2F;\n- test&#x2F;\n- views&#x2F;\n- app.js\n- route.js\n- config.js\n</code></pre><h2>3. 应用入口 <code>app.js</code></h2>\n<hr>\n<p>神圣的入口文件，几乎每个项目都会有一个 entry，对于了解一个应用熟悉入口逻辑很重要。 下面将分步来看看，nodeclub 的 <code>app.js</code> 做了什么：</p>\n<h3>3.1 <code>require(./config)</code></h3>\n<ul>\n<li>3.1.1 应用相关的配置的设置， 主要分为</li>\n</ul>\n<ul>\n<li>1.应用全局数据配置</li>\n<li>2.数据库连接配置</li>\n<li>3.session，auth 相关配置</li>\n<li>4.rss配置</li>\n<li>5.mail配置</li>\n<li>6.第三方连接相关配置， github， weibo</li>\n</ul>\n<p>配置文件也是了解应用的一个好地方， 在 <code>config.default.js</code> 中可以看到以下信息, 这些很可能是我们平时做应用开发的时候没有留意到的地方</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;--应用数据统计\ngoogle_tracker_id: &#x27;UA-41753901-5&#x27;,\n\n&#x2F;&#x2F;--静态文件很可能使用cdn来做\nsite_static_host: &#x27;&#x27;, &#x2F;&#x2F; 静态文件存储域名\n\n&#x2F;&#x2F;--求解释\nsite_enable_search_preview: false, &#x2F;&#x2F; 开启google search preview\nsite_google_search_domain: &#x27;cnodejs.org&#x27;, &#x2F;&#x2F; google search preview中要搜索的域名\n\n&#x2F;&#x2F;--运营数据\nlist_topic_count: 20,\npost_interval: 10000,\nadmins: { admin: true },\nside_ads:[]\nallow_sign_up: true,\n\n&#x2F;&#x2F;--插件模式\nplugins: []\n</code></pre><ul>\n<li>3.1.2 当然这里的配置文件是 default 的，配置文件可以放在一个 <code>config</code> 的文件夹下面，多个文件的方式来整理。比如运营数据配置和其他数据配置分开，因为很有可能需要做一个小的工具来让非技术人员配置相关参数。这时候可以用一个 <code>index.js</code> 作为 facade，相当于一个大的 node module。</li>\n</ul>\n<h3>3.2 <code>require('./models')</code></h3>\n<ul>\n<li>3.2.1 之前已经讲了 <code>models/</code> 目录对应 MVC 的 M 部分。</li>\n<li>3.2.2 <code>models/</code> 目录下面有 <code>index.js</code>, <code>require('./models')</code> 相当于 <code>require('./models/index')</code></li>\n</ul>\n<p>index 相当于一个模型的 facade, <code>index.js</code> 做得事情分别是</p>\n<ul>\n<li>1.connect mongodb</li>\n<li>2.require 各个 model 模块</li>\n<li>3.exports 所有的 model</li>\n</ul>\n<p>简单而言就是初始化了应用 model 层。</p>\n<ul>\n<li>3.2.3 模型使用 orm 框架 mogoose 来写，了解 mogoose 过后， models 部分的代码也就是秒懂了</li>\n</ul>\n<p>， 我说的只是代码，literaly, 一个项目的核心就是 model 的设计，以前做过的任何项目都是一样， 数据库 table 的设计好坏直接影响应用的开发以及性能。 下面来看看各个 model 的 schema 设计(几乎直接 ctr+c, ctr+v 加上了一点点注释) :</p>\n<ul>\n<li>3.2.4 user</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var UserSchema = new Schema({\n &#x2F;&#x2F;--基本用户信息， index表示在mongodb中会建立索引\n &#x2F;&#x2F;--unique: true 唯一性设置\n name: { type: String, index: true },\n loginname: { type: String, unique: true },\n pass: { type: String },\n email: { type: String, unique: true },\n url: { type: String },\n profile_image_url: {type: String},\n location: { type: String },\n signature: { type: String },\n profile: { type: String },\n weibo: { type: String },\n avatar: { type: String },\n githubId: { type: String, index: true },\n githubUsername: {type: String},\n is_block: {type: Boolean, default: false},\n \n &#x2F;&#x2F;--用户产生数据meta\n score: { type: Number, default: 0 },\n topic_count: { type: Number, default: 0 },\n reply_count: { type: Number, default: 0 },\n follower_count: { type: Number, default: 0 },\n following_count: { type: Number, default: 0 },\n collect_tag_count: { type: Number, default: 0 },\n collect_topic_count: { type: Number, default: 0 },\n create_at: { type: Date, default: Date.now },\n update_at: { type: Date, default: Date.now },\n is_star: { type: Boolean },\n level: { type: String },\n active: { type: Boolean, default: true },\n \n &#x2F;&#x2F;-mail\n receive_reply_mail: {type: Boolean, default: false },\n receive_at_mail: { type: Boolean, default: false },\n from_wp: { type: Boolean },\n retrieve_time : {type: Number},\n retrieve_key : {type: String}\n});\n</code></pre><ul>\n<li>3.2.5 topic 话题</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;1 &lt;- 多\n&#x2F;&#x2F;tag &lt;- topic &lt;- collect \nvar TopicSchema = new Schema({\n title: { type: String },\n content: { type: String },\n author_id: { type: ObjectId },\n top: { type: Boolean, default: false },\n reply_count: { type: Number, default: 0 },\n visit_count: { type: Number, default: 0 },\n collect_count: { type: Number, default: 0 },\n create_at: { type: Date, default: Date.now },\n update_at: { type: Date, default: Date.now },\n &#x2F;&#x2F;--这里reply的设计方式不知道是否合适， 因为mongdb不同于关系型数据库，这里每次读取文章都需要重reply集合里边查找遍历一边，文章是读繁忙的。\n &#x2F;&#x2F;-- 一个document的大小为5Mb， 一本牛津词典的内容， 我觉得将reply放在这里应该不会有太大问题。 即便不存放reply 内容， 存放一个id数组也会好很多。\n &#x2F;&#x2F;-- 客官们怎么看? \n last_reply: { type: ObjectId },\n last_reply_at: { type: Date, default: Date.now },\n content_is_html: { type: Boolean }\n});\n\nvar ReplySchema = new Schema({\n content: { type: String },\n topic_id: { type: ObjectId, index: true },\n author_id: { type: ObjectId },\n reply_id : { type: ObjectId },\n create_at: { type: Date, default: Date.now },\n update_at: { type: Date, default: Date.now },\n content_is_html: { type: Boolean }\n});\n\n&#x2F;&#x2F;--话题集合\nvar TopicCollectSchema = new Schema({\n user_id: { type: ObjectId },\n topic_id: { type: ObjectId },\n create_at: { type: Date, default: Date.now }\n});\n\n&#x2F;&#x2F;--话题标签\nvar TopicTagSchema = new Schema({\n topic_id: { type: ObjectId },\n tag_id: { type: ObjectId },\n create_at: { type: Date, default: Date.now }\n}); \n</code></pre><ul>\n<li>3.2.6 tag\n标签系统</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;tag &lt;- collect\nvar TagSchema = new Schema({\n name: { type: String },\n order: { type: Number, default: 1 },\n description: { type: String },\n background: { type: String },\n topic_count: { type: Number, default: 0 },\n collect_count: { type: Number, default: 0 },\n create_at: { type: Date, default: Date.now }\n});\n\nvar TagCollectSchema = new Schema({\n user_id: { type: ObjectId, index: true },\n tag_id: { type: ObjectId },\n create_at: { type: Date, default: Date.now }\n});\n</code></pre><ul>\n<li>3.2.7 关系</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var RelationSchema = new Schema({\n user_id: { type: ObjectId },\n follow_id: { type: ObjectId },\n create_at: { type: Date, default: Date.now }\n});\n</code></pre><ul>\n<li>3.2.8 消息\n消息 model 设计， 对于一个 blog 来说， 基本的只有回复消息， 这里加了关注和@消息。</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;*\n * type:\n * reply: xx 回复了你的话题\n * reply2: xx 在话题中回复了你\n * follow: xx 关注了你\n * at: xx ＠了你\n *&#x2F;\nvar MessageSchema = new Schema({\n type: { type: String },\n master_id: { type: ObjectId, index: true },\n author_id: { type: ObjectId },\n topic_id: { type: ObjectId },\n reply_id: { type: ObjectId },\n has_read: { type: Boolean, default: false },\n create_at: { type: Date, default: Date.now }\n});\n</code></pre><p>###3.3 require middlewares</p>\n<ul>\n<li>\n<p>3.3.1 express 的基础是 middleware，或者说 express 的基础是 connect，connect 的基础是 middleware。middleware 模式在 professional nodejs 中有一个专门的章节来讲解。何为 middleware 呢？ middleware 模式 相当于一个加工流水线（大家叫 middleware stack），每一个 middleware 相当于一个加工步骤，当出现一个 http 请求的时候，http 请求会挨着每个 middleware 执行下去。\nexpress 里处理一个请求的过程基本上就是请求通过 middleware stack 的过程： * -&gt; middlewares -&gt; 路由 -&gt; controllers -&gt; errorhandlering。</p>\n</li>\n<li>\n<p>3.3.2 middleware 怎样做到的， 异步的方法呢？ middleware 使用 promise 的方式来处理异步，所有每个 middleware 都有三个参数 <code>req, res, next</code>, 对于异步的情况， 必须要调用 <code>next()</code> 方法。不然后续的 middleware 就无法执行。 ps: debug 的时候没调用 <code>next()</code> 还不会报错，一定注意</p>\n</li>\n<li>\n<p>3.3.3 auth.js</p>\n</li>\n</ul>\n<p><code>auth.js</code> exports 出来的函数全部都是中间件，从变量名就完全清楚的知道到底在做什么了</p>\n<pre class=\"prettyprint language-javascript\"><code>\n&#x2F;&#x2F;-- 需要admin权限\nexports.adminRequired = function (req, res, next) {}\n\n&#x2F;&#x2F;-- 需要有用户\nexports.userRequired = function (req, res, next) {}\n\n&#x2F;&#x2F;-- 需要有用户并登录\nexports.signinRequired = function (req, res, next) {\n if (!req.session.user) {\n res.render(&#x27;notify&#x2F;notify&#x27;, {error: &#x27;未登入用户不能发布话题。&#x27;});\n return;\n }\n next(); \n}\n\n&#x2F;&#x2F;-- 屏蔽用户 -_-\nexports.blockUser = function (req, res, next) {}\n</code></pre><p>这里其实就可以看到中间件的作用了，我们以前写 php 的时候每次都需要判断用户是否登录， 没登陆 redirect 到 <code>index.php</code> ，只不过这里的方式是通过中间件来处理。\n明白这里什么意思，其他的中间件模块也就秒懂了。</p>\n<p>###3.4 require(’./routes’)</p>\n<ul>\n<li>\n<p>3.4.1 express 的世界里另外一个很重要的就是route， Node.js 启动的是服务， 监听了某一端口， 接受 http or https or socket 请求, 那 url 中像 <code>/index.php?blabla</code> 这一串的存在怎么处理呢， express 的 route 功能就可以帮我们解析。</p>\n</li>\n<li>\n<p>3.4.2 MVC 中如何将一个请求和 controller 联系起来呢， route 就是这样的纽带</p>\n</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;--get, post 请求\napp.get(&#x27;&#x2F;signin&#x27;, sign.showLogin);\napp.post(&#x27;&#x2F;signin&#x27;, sign.login);\n&#x2F;&#x2F;--使用中间件\napp.get(&#x27;&#x2F;signup&#x27;, configMiddleware.github, passport.authenticate(&#x27;github&#x27;));\napp.post(&#x27;&#x2F;:topic_id&#x2F;reply&#x27;, auth.userRequired, limit.postInterval, reply.add);\n</code></pre><ul>\n<li>3.4.3 route 是了解一个应用最佳的地方，一个请求如何处理， 到相应的 controller 去看就知道了。 相比起在PHP环境下配置更加灵活。当然你说你通过nginx来配置也很灵活，好吧，我们说的不是一回事。</li>\n</ul>\n<h3>3.5 initialization</h3>\n<ul>\n<li>3.5.1 experess initialize: <code>app.js</code> 中其他大多部分就是express的初始化了， 初始化流程如下：</li>\n</ul>\n<ul>\n<li>1.配置上传 upload_dir</li>\n<li>2.模板引擎设置</li>\n<li>3.express 通用中间件设置</li>\n<li>4.pasport 中间件</li>\n<li>5.自定义中间件\n<ul>\n<li>1.auth_user</li>\n<li>2.block_user</li>\n<li>3.staticfile: upload</li>\n<li>4.staticfile: user_data</li>\n</ul>\n</li>\n<li>6.csrf</li>\n<li>7.errorhandler</li>\n<li>8.set view cache</li>\n</ul>\n<p><code>[@Note](/user/Note)</code>：配置的顺序很重要， 中间件的执行顺序是按照定义顺序来执行的， 如果一个中间件依赖另外的中间件， 而自己先执行了， 这种情况就会错误。 常见的问题就是session配置， 一定要记得配置 session 中间件的时候， 要先配置 cookieParser。</p>\n<ul>\n<li>3.5.2 session 设置</li>\n</ul>\n<p>这个步骤在 initialize 里边已经有了， 不过再单独讲一下， nodeclub 使用的是 connect-mongo 来作为 session 的存储</p>\n<pre class=\"prettyprint language-javascript\"><code> &#x2F;&#x2F;--cookieParser一定要在前面， 因为session的设置依赖cookie\n app.use(express.cookieParser());\n app.use(express.session({\n secret: config.session_secret,\n store: new MongoStore({\n db: config.db_name,\n }),\n }));\n</code></pre><ul>\n<li>3.5.3 view helpers</li>\n</ul>\n<p>使用过 ejs 的肯定知道， ejs 里边 view helper 设置很简单， 就像赋值变量一样。 当对于一些通用的 helper 可以这样设置：</p>\n<pre class=\"prettyprint language-javascript\"><code> app.helpers({\n config: config,\n Loader: Loader,\n assets: assets\n });\n app.dynamicHelpers(require(&#x27;.&#x2F;common&#x2F;render_helpers&#x27;));\n</code></pre><ul>\n<li>3.5.4 github pasport initialize</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code> &#x2F;&#x2F; github oauth\n passport.serializeUser(function (user, done) {\n done(null, user);\n });\n passport.deserializeUser(function (user, done) {\n done(null, user);\n });\n passport.use(new GitHubStrategy(config.GITHUB_OAUTH, githubStrategyMiddleware));\n</code></pre><ul>\n<li>3.5.5 start app</li>\n</ul>\n<h2>##4. 用户注册</h2>\n<ul>\n<li>4.1 user 是每个应用都会处理的基本， 注册登录登出， 看看 nodeclub 做了哪些事情：</li>\n<li>4.2 路由：</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;--设置能否直接注册， 不能的话通过github注册\nif (config.allow_sign_up) {\n app.get(&#x27;&#x2F;signup&#x27;, sign.showSignup);\n app.post(&#x27;&#x2F;signup&#x27;, sign.signup);\n} else {\n app.get(&#x27;&#x2F;signup&#x27;, configMiddleware.github, passport.authenticate(&#x27;github&#x27;));\n}\napp.post(&#x27;&#x2F;signout&#x27;, sign.signout);\napp.get(&#x27;&#x2F;signin&#x27;, sign.showLogin);\napp.post(&#x27;&#x2F;signin&#x27;, sign.login);\n</code></pre><ul>\n<li>4.3 controller &amp; model：sign.signup</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>sanitize = validator.sanitize;\ncheck = validator.check;\nexports.signup = function (req, res, next) {\n &#x2F;&#x2F;--xss 消毒\n var name = sanitize(req.body.name).trim();\n name = sanitize(name).xss();\n ...\n &#x2F;&#x2F;--validations\n try {\n check(name, &#x27;用户名只能使用0-9，a-z，A-Z。&#x27;).isAlphanumeric();\n } catch (e) {\n res.render(&#x27;sign&#x2F;signup&#x27;, {error: e.message, name: name, email: email});\n return;\n }\n ...\n &#x2F;&#x2F;--用用户名登录或者email登录\n query = {&#x27;$or&#x27;: [{&#x27;loginname&#x27;: loginname}, {&#x27;email&#x27;: email}]}\n User.getUserByQuery(query, {}, function(){\n ...\n pass = md5(pass);\n ...\n User.newAndSave(name, loginname, pass, email, avatar_url, false, function (err) {\n ...\n &#x2F;&#x2F; 发送激活邮件\n mail.sendActiveMail(email, md5(email + config.session_secret), name);\n res.render(&#x27;sign&#x2F;signup&#x27;, {\n success: &#x27;欢迎加入 &#x27; + config.name + &#x27;！我们已给您的注册邮箱发送了一封邮件，请点击里面的链接来激活您的帐号。&#x27;\n });\n })\n })\n} \n</code></pre><h2>##5. mongoose 的使用</h2>\n<ul>\n<li>5.1 使用User.newAndSave，</li>\n<li>5.2 异步 callback pyramid</li>\n</ul>\n<p>一个应用通常会遇到这样的情景， 一个页面需要的数据包括， 文章列表， 评论列表，用户数据，广告数据， other stuff… 问题是每个都是异步的， 怎么办。 user 数据获取过后的 callback 调用文章列表获取， 文章列表获取的 callback 调用评论列表的获取… 这样就太蛋疼了。 nodeclub 使用了 eventproxy 模块优雅的解决这样的问题：</p>\n<pre class=\"prettyprint language-javascript\"><code> render = function(){}\n var proxy = EventProxy.create(&#x27;tags&#x27;, &#x27;topics&#x27;, &#x27;hot_topics&#x27;, &#x27;stars&#x27;, &#x27;tops&#x27;, &#x27;no_reply_topics&#x27;, &#x27;pages&#x27;, render);\n proxy.fail(next);\n Tag.getAllTags(proxy.done(&#x27;tags&#x27;));\n Topic.getTopicsByQuery(query, options, proxy.done(&#x27;topics&#x27;));\n User.getUsersByQuery({ is_star: true }, { limit: 5 }, proxy.done(&#x27;stars&#x27;));\n</code></pre><p>看完代码不言而喻。。。\n当然异步处理的方法有很多:</p>\n<ul>\n<li>1.基于事件的：eventProxy</li>\n<li>2.基于promise的：Async.js Q.js, when.js</li>\n<li>3.基于编译的：continuation, wind</li>\n<li>4.基于语言语法的：yield， livescript</li>\n</ul>\n<p>文章最后会讲一下我我的异步选择方案</p>\n<h2>##6. 消息</h2>\n<ul>\n<li>6.1 原先以为有动态的消息推送， 有队列处理， 错了， 木有</li>\n<li>6.2 在 Sublime text 里边全局搜索 <code>sendReply2Message</code> 会发现是在 <code>controller/reply.js</code> 里边调用的， 也就是说，消息是直接触发的。</li>\n<li>6.3 好吧， 这部分大概大家都能秒懂。。</li>\n</ul>\n<h2>##7. 开发</h2>\n<p>###7.1 测试</p>\n<ul>\n<li>7.1.1 一个项目必定离不开测试， nodeclub基于mocha BDD测试框架， 一切的前提假设至少能看懂jasmine或者mocha或者任何一个BDD风格的测试代码。</li>\n<li>7.1.2 打开即看到app.js</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var app = require(&#x27;..&#x2F;app&#x27;);\ndescribe(&#x27;app.js&#x27;, function () {\n &#x2F;&#x2F;--before， 执行it的前面会执行\n before(function (done) {\n &#x2F;&#x2F;--done, 异步方法\n app.listen(3001, done);\n });\n after(function () {\n app.close();\n });\n it(&#x27;should &#x2F; status 200&#x27;, function (done) {\n &#x2F;&#x2F;--使用 app.request()就可以模拟请求了？ 这个api哪里来的， 求解释？\n app.request().get(&#x27;&#x2F;&#x27;).end(function (res) {\n res.should.status(200);\n done();\n });\n });\n});\n&#x2F;&#x2F;--按理说应该是可以正常运行了但是我一直出现这个错误:\n&#x2F;&#x2F;--connect ADDRNOTAVAIL 知道的求解释\n&#x2F;&#x2F;--我尝试用supertest直接测试， 但是也是一直timeout， mocha\n&#x2F;&#x2F;--里边加大timeout时间， 结果就是一直没反应。 \n\n&#x2F;&#x2F;--分析原因， express版本问题， nodeclub中express的版本还是2.x, 所以才会有\n&#x2F;&#x2F;--app.request(), app.close()这些api\n&#x2F;&#x2F;--第二个原因， 到supertest官网， 发现人家都已经转战到superagent项目了， 于是我写了下面这个测试脚本， 可以通过了\nvar express = require(&#x27;express&#x27;);\nvar should = require(&#x27;should&#x27;);\nvar path = require(&#x27;path&#x27;);\nvar superagent = require(&#x27;superagent&#x27;);\nvar app = express()\napp.get(&#x27;&#x2F;user&#x27;, function(req, res, next) {\n res.send(200, {\n name: &#x27;tobi&#x27;\n })\n})\ndescribe(&#x27;myapp.js&#x27;, function() {\n this.timeout(5000)\n before(function(done) {\n app.listen(21, done);\n })\n after(function() {\n &#x2F;&#x2F; app.close()\n })\n it(&#x27;should &#x2F;status 200&#x27;, function(done) {\n agent = superagent.agent()\n agent.get(&#x27;http:&#x2F;&#x2F;localhost:21&#x2F;user&#x27;).end(function(err, res) {\n console.log(err, res)\n res.should.have.status(200);\n res.text.should.include(&#x27;tobi&#x27;);\n return done();\n });\n })\n})\n</code></pre><p>###7.2 运行</p>\n<ul>\n<li>nodejs是单线程应用， 如果我们用node命令来运行我们的应用， 当出现一个小错误， 它就挂了。 然后没有然后了。 避免这种问题的方法有如下工具：</li>\n</ul>\n<ul>\n<li>1.forever</li>\n<li>2.nodemon</li>\n<li>3.supervisor\nnodeclub 使用 forever 来运行项目， 使用这类工具的好处就是， 当有代码改动过后， 会自动的重启应用。 不必每次自己去运行 <code>node *.js</code></li>\n</ul>\n<h2>##8. 说说自己的经验</h2>\n<p>待续…\n###8.1 消息订阅设计\n###8.2 express + socket\n###8.3 异步\n###8.4 Action</p>\n</div>",
"title": "通过 nodeclub 项目源码来讲解如何做一个 nodejs + express + mongodb 项目",
"last_reply_at": "2016-08-01T23:48:49.923Z",
"good": true,
"top": false,
"reply_count": 76,
"visit_count": 26930,
"create_at": "2014-04-22T05:44:02.557Z",
"author": {
"loginname": "6174",
"avatar_url": "https://avatars.githubusercontent.com/u/3872872?v=3&s=120"
}
},
{
"id": "577d8646abe833170602610e",
"author_id": "577d81cce538b3ee7889ffce",
"tab": "job",
"content": "<div class=\"markdown-text\"><p>职位要求:\n熟练运用Node.js, React, Redux, ES6, Webpack, 熟悉UI开发及后端NoSql (mongodb等)\n有以下经验更佳: Graphql, Elastic Search, Relay, ES7, KOA, Reactive programming ,SQL , Python\n弹性工作时间, 可远程\n实习生300-800/天, 可转正\n全职薪酬根据技术程度而定, 不设上限\n请email 简历至 newadev At <a href=\"http://unidt.com\">unidt.com</a> , 当天回复</p>\n<p>公司: 华院数据在大数据分析、挖掘及应用领域深耕十几年，成功帮助电信、电商、零售、金融、制造等领域的客户利用大数据提升效率、降低成本和增加营收。目核心业务为：产业大数据应用、深度孵化(数据实验室)、数据互联和智能引擎。</p>\n<p>地点: 可在上海, 杭州, 北京, 西安或成都入职, 或远程工作</p>\n</div>",
"title": "[上海 杭州 北京 西安 成都 *远程*] Node.js React 实习生(3), 全职(2)",
"last_reply_at": "2016-08-01T19:13:09.820Z",
"good": false,
"top": false,
"reply_count": 22,
"visit_count": 2065,
"create_at": "2016-07-06T22:29:26.570Z",
"author": {
"loginname": "React1010",
"avatar_url": "https://avatars.githubusercontent.com/u/20327783?v=3&s=120"
}
},
{
"id": "579d7261da05b9e92af3258b",
"author_id": "53ac16d8c3ee0b5820b8fcff",
"tab": "share",
"content": "<div class=\"markdown-text\"><p>直播的内容如下：</p>\n<ol>\n<li>平时会研究一些新的工具，比如docker啊，elastic search啊，iOS或者安卓的一些有趣的库啊之类的。</li>\n<li>可以应水友的要求，演示一些代码编写。</li>\n<li>如果水友想了解某个工具，但又懒得自己去研究，可以向我提出，有趣的话我会直播研究。</li>\n</ol>\n<p>直播时间：\n每周一三五晚8：00~10：30</p>\n<p>有兴趣的人欢迎来看哈，直播地址：\n<a href=\"http://www.douyu.com/kilik52\">http://www.douyu.com/kilik52</a></p>\n<p>个人介绍：\n技术栈：\niOS（OBJC，swift）、安卓（JAVA）、NodeJS、 AngularJS</p>\n<p>自己开了个公司做自主产品和外包。 平时没有维护什么开源库什么的。不过有一个产品：\n<a href=\"http://shaozi.info\">http://shaozi.info</a>， 这个产品的前端、后端、iOS和安卓都是我一个人开发的（后来招了两个人用来加快进度）</p>\n</div>",
"title": "打算直播编程，不知道有没有人有兴趣",
"last_reply_at": "2016-08-01T15:27:15.802Z",
"good": false,
"top": false,
"reply_count": 8,
"visit_count": 482,
"create_at": "2016-07-31T03:37:05.660Z",
"author": {
"loginname": "kilik52",
"avatar_url": "https://avatars.githubusercontent.com/u/37238?v=3&s=120"
}
},
{
"id": "579f4ce59f22cae71c654290",
"author_id": "579f4a749f22cae71c65428f",
"tab": "job",
"content": "<div class=\"markdown-text\"><p>公司业务飞速发展，需要node+mongodb技术人才，待遇优厚。</p>\n<p>公司网站：<a href=\"http://www.i-xiaoqu.com\">www.i-xiaoqu.com</a></p>\n<p>您可以在微信中搜索“智取管家”公众号 ，关注了解更多信息。</p>\n<p>微信号、手机号：13968125683</p>\n<p>王先生。。。。。。。。</p>\n</div>",
"title": "【杭州】--礼邻网络 node + mongodb高级工程师",
"last_reply_at": "2016-08-01T13:21:41.193Z",
"good": false,
"top": false,
"reply_count": 0,
"visit_count": 110,
"create_at": "2016-08-01T13:21:41.193Z",
"author": {
"loginname": "chunlianwang",
"avatar_url": "https://avatars.githubusercontent.com/u/20772872?v=3&s=120"
}
},
{
"id": "579f12dbda05b9e92af325e6",
"author_id": "5799900b2d740f7c26637f3d",
"tab": "ask",
"content": "<div class=\"markdown-text\"><p>网上说是版本锁，源码里面没找到它是怎么改变“__V“的值\n那__v的值在什么情况下会改变？</p>\n</div>",
"title": "mongoose的__v字段有什么用？",
"last_reply_at": "2016-08-01T12:53:59.392Z",
"good": false,
"top": false,
"reply_count": 2,
"visit_count": 108,
"create_at": "2016-08-01T09:14:03.766Z",
"author": {
"loginname": "yuxinhua0",
"avatar_url": "https://avatars.githubusercontent.com/u/20109390?v=3&s=120"
}
},
{
"id": "579f161541404b052be5daa7",
"author_id": "51d37c80d44cbfa304285441",
"tab": "ask",
"content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fp46L6xvjXDwAxKPZ6DjTVgMZ38o\" alt=\"12.pic.jpg\">\n<img src=\"//dn-cnode.qbox.me/FiLZunpqX0RTfcffcBHIIUK4jnCq\" alt=\"14.pic.jpg\">\n<img src=\"//dn-cnode.qbox.me/FkbFDDsOTSbAzBKEnitpxZutGT2X\" alt=\"13.pic.jpg\"></p>\n<p>以上是代码内容，基本是 <a href=\"https://github.com/moajs/moa2\">moa2</a> 的 代码，router 由于使用了 koa-router get方法的第二个参数 是需要使用Generator 函数的，已修改。\n然后就是 views 中间件，源码是</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = views(path.join(__dirname, &#x27;..&#x2F;..&#x2F;app&#x2F;views&#x27;), {\n extension: &#x27;jade&#x27;\n})\n</code></pre><p>已根据 <a href=\"https://cnodejs.org/topic/557298dac4e7fbea6e9a2f17\">koa如何使用jade，倒饬了2天了</a> 这篇内容修改了。\n但还是 404\nrouter 内修改成 this.body = ‘Hello World’ 可以正常出来，所以就剩下 return this.render(‘index’, {\ntitle: ‘Hello World’\n});</p>\n<p>path.join(__dirname, ‘…/…/app/views’ 部分 使用 过 ‘…/app/views’ ，’/app/views’ ，’/views’ ，‘views’ 都是 404\n甚至 我在根目录也开了一个一样的views 文件夹也是不可以</p>\n<p><img src=\"//dn-cnode.qbox.me/FrD2qJrMNPp553aaEyN42MhIHnsi\" alt=\"屏幕快照 2016-08-01 下午5.25.29.png\">\n<img src=\"//dn-cnode.qbox.me/FlxkeBXPzthmPhjalDNzk2eszlN6\" alt=\"屏幕快照 2016-08-01 下午5.25.16.png\">\n这两个jade 的内容 目测也没有问题吧……</p>\n<p>请了解的大牛指导一下，怎样才不404</p>\n</div>",
"title": "Koa2 上 关于 jade 的配置问题",
"last_reply_at": "2016-08-01T12:50:49.462Z",
"good": false,
"top": false,
"reply_count": 3,
"visit_count": 74,
"create_at": "2016-08-01T09:27:49.719Z",
"author": {
"loginname": "thomas0836",
"avatar_url": "//gravatar.com/avatar/b62fb4edd06b28eb30c575af5fed1c61?size=48"
}
},
{
"id": "5771eb20d3baaf401780bc41",
"author_id": "563f17d0b0cedafd38970462",
"tab": "share",
"content": "<div class=\"markdown-text\"><h2>前言</h2>\n<p>加密货币是一种数字资产，随着区块链等相关技术的创新和突破，很多有形或无形资产实现了去中心化。比如我们这里分享的 <a href=\"http://ebookchain.org/\">亿书</a> 就是要把数字出版物版权进行保护，实现去中心化，解决业界多年来版权保护不力的难题。</p>\n<p>无论数字资产，还是数字出版版权，都是有明确所有权的，当前实现数字资产所属的技术手段就是本篇要介绍的<code>签名</code>。而<code>多重签名</code>是对<code>签名</code>的扩展使用，给数字资产转移提供了安全保障和技术手段。本篇，从基本概念入手，详细了解<code>签名</code>和<code>多重签名</code>的作用和代码实现。</p>\n<h2>源码</h2>\n<p>主要源码地址：</p>\n<p>signatures.js <a href=\"https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js\">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js</a></p>\n<p>multisignatures.js <a href=\"https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js\">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js</a></p>\n<h2>解读</h2>\n<h4>签名</h4>\n<p>（1）签名的作用和特点</p>\n<p><strong>名字的解释</strong>。<code>签名</code>是什么？有人第一反应是日常生活中的用笔<code>签名</code>，那么我会说，你的直觉是对的。不过，当很多小伙伴看到网上的很多解释，却又迷惑了，事实上不同概念在不同领域的表述是有差别的，但本质相同。我坚信生活是一切创作的源泉，任何一个概念都能从生活中找到原型，这里的“签名”也是如此。</p>\n<p><strong>签名的作用</strong>。日常生活中，凡是需要确认归属的（是签名人的，不是其他的），都需要所有者进行签名。比如，我签名了一份文件，出了问题，责任我负，我签名了一个支票，就代表将由我支付。我们普通老百姓最常见的场景，就是去银行办业务，银行职员会让你反复签一大堆的单据，想必每个人都会有深刻的印象。</p>\n<p><strong>签名的特点</strong>。人的笔迹是很个性化的，越熟练的字体，个性特征越固定，因此一个人的名字，不同的人写出完全相同笔迹的概率非常小，即便是专业模仿也可以通过技术鉴别出来，这样一来，人的<code>签名</code>就具有唯一性、可验证的特点，并被法律认可。</p>\n<p><strong>签名的验证</strong>如果，你拿着一张支票去银行兑换，银行职员会对支票上的签名和印章仔细比对，确保印章大小、样式，以及付款人签名等，与银行留存的信息一致，才会给你兑付，这就是<code>签名</code>验证。</p>\n<p>（2）比特币客户端签名功能</p>\n<p>数字资产需要签名。类比人类签名，比特币也有签名功能。如果了解比特币钱包（客户端软件），就会发现它提供了一个消息签名的功能，可以用来对其他用户通过比特币网络之外的信息进行签名和验证。我个人使用的是 <a href=\"https://www.bitcoin.org/\">比特币官方网站</a> 提供的比太钱包，如图：</p>\n<p><img src=\"//dn-cnode.qbox.me/FsXV4VnyyFu45QXY0WBB-iSTRfNa\" alt=\"bither-wallet-sign.png\"></p>\n<p>这个功能干什么用的呢？有好多小伙伴不清楚，这里举个简单的例子解释一下，具体使用的时候绝不限于这些应用。</p>\n<p>Alice开了一个网店，但没有直接接入比特币网络，不能自动确认和验证支付者。客户Imfly购买了她的产品，并用比特币支付了全部货款。因为比特币地址和交易都是公开匿名的，为了防止冒充冒领实，Alice需要确认Imfly提供的那个付款地址确实是imfly本人的，否则不能发货。这时候，就需要Imfly先把支付货款的比特币地址和相关交易<code>签名信息</code>（如图），然后通过QQ或邮件传给Alice，Alice使用客户端<code>验证信息签名</code>，才能确认交易确实是Imfly的。</p>\n<p>想象一下，如果没有<code>签名</code>功能会怎么样呢？因为比特币仅是一个匿名、安全的支付手段，但却无法确认支付方或收款方是谁，信息的不确定性，将使得比特币网络之外的交易无法达成。在中心化的世界里，这个问题是通过运营平台这个第三方达成的，比如支付宝等，双方的全部信息，平台都掌握，任何一方出现欺诈，都需要通过向平台投诉来解决。用户需要对第三方平台绝对信任，并通过牺牲个人信息安全获得交易的基本保障。</p>\n<p>（3）电子签名</p>\n<p>通过上述分析，可以理解的是，<code>签名</code>的作用是确定资产所属，其特征是简单、安全、可验证。把这个概念抽象出来，应用到计算机系统里，为了确定数字资产所属，也需要进行<code>签名</code>，这就是大家经常看到的“电子签名”的概念。在网络世界里，<code>签名</code>可以对任何需要确认的数字资产进行处理，比如比特币地址、电子书版权等，并以此来宣告重要资产的所属，这让无需监管的去中心化交易成为可能。</p>\n<p>具体开发设计中，就是加密技术代替人的笔迹，不然任何签名方法都会被模仿，而且模仿的成本极低，相反，验证的成本却很高。具体的加密或验证技术，请参考前面的章节，这里我们介绍亿书是如何使用签名技术的。</p>\n<p>亿书也具备签名能力，只不过，目前没有单独提供<code>签名信息</code>的操作供用户使用，而是通过签名，添加了<code>支付密码</code>功能，对用户帐号资产追加了一层保护。</p>\n<p>（4）亿书的支付密码</p>\n<p><code>签名</code>方法在<code>modules/signatures.js</code>文件里，类图如下：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fjs42b_dNJLS814GIodgr0jZsvjt\" alt=\"signatures-class.png\"></p>\n<p>我们还是从Api开始，代码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; modules&#x2F;signatures.js文件\n&#x2F;&#x2F; 179行\nrouter.map(shared, {\n &quot;get &#x2F;fee&quot;: &quot;getFee&quot;,\n &quot;put &#x2F;&quot;: &quot;addSignature&quot;\n});\n\n&#x2F;&#x2F; 188行\nlibrary.network.app.use(&#x27;&#x2F;api&#x2F;signatures&#x27;, router);\n</code></pre><p>通过上面的代码，可以了解<code>签名</code>提供了两个简单的公共接口：</p>\n<pre class=\"prettyprint\"><code>get &#x2F;api&#x2F;signatures&#x2F;fee -&gt; shared.getFee\nput &#x2F;api&#x2F;signatures&#x2F; -&gt; shared.addSignature &#x2F;&#x2F;签名操作\n</code></pre><p>显然，最核心的方法也就是<code>shared.addSignature</code>，代码：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 215行\nshared.addSignature = function (req, cb) {\n\t...\n\tlibrary.scheme.validate(body, {\n\t\tproperties: {\n\t\t\t...\n\t\t},\n\t\trequired: [&quot;secret&quot;, &quot;secondSecret&quot;]\n\t}, function (err) {\n\t\t...\n\n\t\tlibrary.balancesSequence.add(function (cb) {\n\t\t\tif (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#x27;hex&#x27;)) {\n\t\t\t\tmodules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {\n\t\t\t\t\t...\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar transaction = library.logic.transaction.create({\n\t\t\t\t\t\t\t\ttype: TransactionTypes.SIGNATURE, &#x2F;&#x2F; 297行\n\t\t\t\t\t\t\t\tsender: account,\n\t\t\t\t\t\t\t\tkeypair: keypair,\n\t\t\t\t\t\t\t\trequester: keypair,\n\t\t\t\t\t\t\t\tsecondKeypair: secondKeypair,\n\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treturn cb(e.toString());\n\t\t\t\t\t\t}\n ...\t\t\t\n}\n</code></pre><p>毫无疑问，<code>支付密码</code>也是一个简单的交易（交易类型<code>TransactionTypes.SIGNATURE</code>，见297行）。基于此，我们不难想象，添加类似比特币的<code>签名</code>功能也是件非常简单的事情，我们会在亿书下一个版本里添加这项功能，具体请关注 <a href=\"https://github.com/Ebookcoin/ebookcoin\">亿书币版本库</a> 最新进展。</p>\n<h4>多重签名</h4>\n<p>上面我们提到，比特币的匿名性，使交易处于不可信之中，最终导致用户不敢交易。有了签名功能，就有了确认双方信息的有效手段，问题总算有了解决方案。聪明的小伙伴会发现，签名和验证过程除了繁琐，并没有让我们觉得比使用第三方平台更有效、更安全。有没有更好的解决方案呢？回答是：有，那就是多重签名。</p>\n<p>（1）基本概念</p>\n<p>多重签名，可以简单的理解为一个数字资产的多个签名。签名标定的是数字资产所属和权限，多重签名预示着数字资产可由多人支配和管理。在加密货币领域，如果要动用一个加密货币地址的资金，通常需要该地址的所有人使用他的私钥（由用户专属保护）进行签名。那么，多重签名，就是动用这笔资金需要多个私钥签名，通常这笔资金或数字资产会保存在一个多重签名的地址或帐号里。这就好比，我们工作中有一份文件，需要多个部门签署才能生效一样。</p>\n<p>在实际的操作过程中，一个多重签名地址可以关联n个私钥，在需要转账等操作时，只要其中的m个私钥签名就可以把资金转移了，其中m要小于等于n，也就是说m/n小于1，可以是2/3, 3/5等等，是要在建立这个多重签名地址的时候确定好的。</p>\n<p>（2）工作原理</p>\n<p>数字资产在某种情况下，需要多人支配。换句话说，在某些特定条件下，数字资产如果无法确认归属某个特定的人，那么最好让相关人共同签署它的所有权。</p>\n<p>仍然举上面的例子，在Alice发货之后，Imfly收到货之前，这笔钱应该由第三方信用比较高的中介暂时保存，这个阶段，这笔钱要么是Alice的，要么是Imfly的，最终的归属要看Imfly是否收到货。所以，这个第三方，无论如何都是应该有的，不然Imfly就要承担大部分风险（因为比特币的单向不可逆，Imfly发送之后就没有办法收回了）</p>\n<p>这样一来，这笔钱的所属关系，在交易过程中涉及到Alice、Imfly和平台第三方（虽然不属于它，但它有权裁定资金去向），那么就应该由他们三方签名，因此网上购物就是典型的多重签名的例子。其多重签名模型就是2/3，也就是说只要他们中的两个签名，资金就可以被转移。</p>\n<p>具体到这个例子，Imfly把钱打给一个关联三方私钥的多重签名地址，如果整个交易过程顺利，只要Alice和Imfly两个签名，这笔钱就会顺利到达Alice手里。如果不顺利，他们任何一人提出仲裁，平台第三方调查之后，通过签名就能把这笔钱转给Alice或退回Imfly。这非常类似淘宝和京东的模式，但是比他们更加便捷和安全，至少不用担心第三方倒闭、挪用资金或携款跑路。</p>\n<p>（3）应用场景</p>\n<p>很显然，多重签名给了加密货币腾飞的翅膀，让它单一单项支付的能力更具吸引力，让加密货币技术应用到各行各业成为可能。这里简单的罗列几个应用场景，供探索和思考：</p>\n<ul>\n<li>电子商务。比较常见的是2/3的模式。上面电子商务网站的例子，就是最典型的场景之一，目前已经有成功的案例了。延伸一下，这类应用本质就是中介，所以还可用在各类中介机构性质的服务上。</li>\n<li>财产分割。比如夫妻双方共有财产，可以使用1/2的模式，一个账户谁都可以使用，跟各自拥有帐号一样，好处是系统忠实记录了每个人的花销，闹掰的时候很容易清算。扩展到公司合伙经营，可以使用1/n模式，n个人合伙人，都可以直接支配共有资金，具体清算时，一目了然。</li>\n<li>资金监管。其实，这是多重签名的最直接作用，一笔钱需要多个人签名才能使用，任何一个人都无法直接动用资金，这在生活中太常见了，只要灵活设置多重签名的比重模式，就能解决生活中很多问题。比如，接着上面夫妻的例子，夫妻要储备一笔资金，供孩子上大学使用，在这之前谁都不能动，那么把模式改为2/2，不仅限制了夫妻双方，也给黑客攻击增加了难度。</li>\n</ul>\n<p>多重签名的设计，让各种业务去中心化充满无限可能。</p>\n<p>（4）亿书的多重签名</p>\n<p><code>多重签名</code>方法在<code>modules/multisignatures.js</code>文件里，类图如下：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fl9Su_riyYM3LBSVZcnj9mLxk0A3\" alt=\"multisignatures-class.png\"></p>\n<p>实现Api的代码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 318行\nrouter.map(shared, {\n &quot;get &#x2F;pending&quot;: &quot;pending&quot;, &#x2F;&#x2F; Get pending transactions\n &quot;post &#x2F;sign&quot;: &quot;sign&quot;, &#x2F;&#x2F; Sign transaction\n &quot;put &#x2F;&quot;: &quot;addMultisignature&quot;, &#x2F;&#x2F; Add multisignature\n &quot;get &#x2F;accounts&quot;: &quot;getAccounts&quot;\n});\n\n&#x2F;&#x2F; 329行\nlibrary.network.app.use(&#x27;&#x2F;api&#x2F;multisignatures&#x27;, router);\n</code></pre><p>解析一下，最后产生的Api如下：</p>\n<pre class=\"prettyprint\"><code>get &#x2F;api&#x2F;multisignatures&#x2F;pending -&gt; shared.pending &#x2F;&#x2F; 查询等待中的交易\npost &#x2F;api&#x2F;multisignatures&#x2F;sign -&gt; shared.sign &#x2F;&#x2F; 签名交易\nput &#x2F;api&#x2F;multisignatures&#x2F; -&gt; shared.addMultisignature &#x2F;&#x2F; 创建多重签名帐号\nget &#x2F;api&#x2F;multisignatures&#x2F;accounts -&gt; shared.getAccounts &#x2F;&#x2F; 获得关联的帐号（对应者用户私钥）\n</code></pre><p>提供的功能很显然，包括：待交易查询、关联帐号列表查询，用户签名交易，创建多重签名帐号等4个核心功能。我们先从创建多重签名帐号开始，这个Api使用的是http的<code>put</code>方法，对应的自然是<code>更新</code>操作，不查看代码也可以猜想到，该功能应该是在已有帐号基础上的操作，从客户端钱包<code>设置</code>菜单里，可以看到如图操作：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fn8bESMoaWz3rnQAE-OuBD-oy3dD\" alt=\"addMultisignature.png\"></p>\n<p>看看<code>shared.addMultisignature</code>的源代码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; modules&#x2F;multisignatures.js文件\nshared.addMultisignature = function (req, cb) {\n\tvar body = req.body;\n\tlibrary.scheme.validate(body, {\n\t\t...\n\n &#x2F;&#x2F; 732行\n\t\trequired: [&#x27;min&#x27;, &#x27;lifetime&#x27;, &#x27;keysgroup&#x27;, &#x27;secret&#x27;]\n\t}, function (err) {\n\t ...\n\n\t\tlibrary.balancesSequence.add(function (cb) {\n\t\t\tmodules.accounts.getAccount({publicKey: keypair.publicKey.toString(&#x27;hex&#x27;)}, function (err, account) {\n\t\t\t\t...\n\n &#x2F;&#x2F; 767行\n\t\t\t\ttry {\n\t\t\t\t\tvar transaction = library.logic.transaction.create({\n\t\t\t\t\t\ttype: TransactionTypes.MULTI, &#x2F;&#x2F; 769行\n\t\t\t\t\t\tsender: account,\n\t\t\t\t\t\tkeypair: keypair,\n\t\t\t\t\t\tsecondKeypair: secondKeypair,\n\t\t\t\t\t\tmin: body.min,\n\t\t\t\t\t\tkeysgroup: body.keysgroup,\n\t\t\t\t\t\tlifetime: body.lifetime\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn cb(e.toString());\n\t\t\t\t}\n\n\t\t\t\t...\n};\n</code></pre><p>从732行可知，创建一个多重签名，必须’min’, ‘lifetime’, ‘keysgroup’, 'secret’这四参数（其实，一个默认参数就是当前帐号），min代表上面讲到的<code>m</code>值，即需要确认的人数;lifetime代表生命周期;keysgroup包含多重签名关联的全部帐号，它是数组类型，包含的元素个数就是<code>n</code>;secret是用户密码，与用户私钥对应。</p>\n<p>经过一系列的验证之后，作为一个交易（交易类型TransactionTypes.MULTI，769行）保存到数据库(区款链)里。创建成功的帐号，可以显示多重帐号菜单，对交易进行操作。接下来，自然应该能够查看全部关联的帐号（请看shared.getAccounts方法），查看<code>待确认的交易</code>（请看shared.pending方法），这两个方法仅仅是简单的查询，没什么难度，这里不再浪费篇幅。</p>\n<p>如果用户同意交易，就可以对<code>待确认的交易</code>进行签名（shared.sign方法），这个方法的源码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 586行\nshared.sign = function (req, cb) {\n\tvar body = req.body;\n\tlibrary.scheme.validate(body, {\n\t\t...\n\t\trequired: [&#x27;transactionId&#x27;, &#x27;secret&#x27;]\n\t}, function (err) {\n\t\t...\n\n &#x2F;&#x2F; 632行\n\t\tfunction done(cb) {\n\t\t\tlibrary.balancesSequence.add(function (cb) {\n &#x2F;&#x2F; 634行\n\t\t\t\tvar transaction = modules.transactions.getUnconfirmedTransaction(body.transactionId);\n\n\t\t\t\tif (!transaction) {\n\t\t\t\t\treturn cb(&quot;Transaction not found&quot;);\n\t\t\t\t}\n\n &#x2F;&#x2F; 640行\n\t\t\t\ttransaction.signatures = transaction.signatures || [];\n\t\t\t\ttransaction.signatures.push(sign);\n\n\t\t\t\tlibrary.bus.message(&#x27;signature&#x27;, {\n\t\t\t\t\tsignature: sign,\n\t\t\t\t\ttransaction: transaction.id\n\t\t\t\t}, true);\n\t\t\t\tcb();\n\t\t\t}, function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err.toString());\n\t\t\t\t}\n\n\t\t\t\tcb(null, {transactionId: transaction.id});\n\t\t\t});\n\t\t}\n\n\t\t...\n};\n</code></pre><p>这个方法，相比单独的签名方法，不同的是单独的签名方法相当于一个新建交易，而这里的多重签名的用户签名，显然仅仅是对未确认交易（634行）进行签名确认（640行维护了一个签名数组，641行的push方法把用户签名写入数组）。而且，相比独立签名，验证也更复杂，我们将在下一篇《交易》一文中集中讨论验证问题。您也可以结合下一篇的内容，阅读和理解这里的签名方法。</p>\n<h2>总结</h2>\n<p>在加密货币里，每一个交易都涉及到使用私钥签名，用于确认每笔资金所有人。确定了所有人，自然就确定了资金转移的条件、目标和方向，就为我们下一步进行资金转移操作奠定了基础。很自然的，该研究一下亿书的交易了，请看下一篇：<strong>《交易》</strong>。</p>\n<h2>链接</h2>\n<p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p>\n<p>本源文地址： <a href=\"https://github.com/imfly/bitcoin-on-nodejs\">https://github.com/imfly/bitcoin-on-nodejs</a></p>\n<p>区块链俱乐部： <a href=\"http://chainclub.org\">http://chainclub.org</a></p>\n<p>亿书官方网站： <a href=\"http://ebookchain.org\">http://ebookchain.org</a></p>\n<p>亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与）</p>\n<h2>参考</h2>\n<p><a href=\"http://ebookchain.org/ebookchain.pdf\">亿书白皮书 http://ebookchain.org/ebookchain.pdf</a></p>\n</div>",
"title": "《Nodejs开发加密货币》之十七：签名和多重签名",
"last_reply_at": "2016-08-01T12:39:44.911Z",
"good": false,
"top": false,
"reply_count": 12,
"visit_count": 535,
"create_at": "2016-06-28T03:12:32.603Z",
"author": {
"loginname": "imfly",
"avatar_url": "https://avatars.githubusercontent.com/u/12215508?v=3&s=120"
}
},
{
"id": "520dc59899f5db772c01ce1f",
"author_id": "51cbfbde73c638f37039ea00",
"content": "<div class=\"markdown-text\"><p>javascript实现单例模式有很多种方法</p>\n<p>一、使用全局变量保存单例</p>\n<p>这是最简单的实现方法</p>\n<pre class=\"prettyprint\"><code>function Person(){ \n this.createTime=new Date(); \n} \n\nvar instance=new Person(); \nfunction getInstance(){ \n return instance; \n} \n</code></pre><p>加载该js时就创建一个Person对象，保存到instance全局变量中，每次使用都取这个对象。如果一次都没使用，那么创建的这个对象则浪费了，我们可以优化一下，</p>\n<pre class=\"prettyprint\"><code>var instance \nfunction getInstance(){ \n if(!instance){ \n instance=new Person(); \n } \n return instance; \n} \n</code></pre><p>这样，第一次使用时才创建对象。\n这个方法的缺点是，instance是全局的变量，在多人合作或者开发周期比较长的情况下，很难保证instance不会被其它代码修改或覆盖，很可能到调用的时候，发现instance根本就不是Person对象。\n我们考虑下使用闭包来封装起instance，使它不再是全局变量就可以解决这个问题了</p>\n<p>二、闭包创建对象</p>\n<pre class=\"prettyprint\"><code>var getInstance(){ \nvar instance; \nreturn function(){ \n if(!instance){ \n instance=new Person(); \n } \n return instance; \n } \n}(); \n</code></pre><p>这样，instance就被封装起来了，不用担心被修改了。\n现在通过getInstance()函数可以获得单例了。新的问题，如果我通过new Person()来创建对象，获得的还是多个对象，javascript又不可以像java一样把构造器私有化。那怎么样可以让多次new出来的对象都是一个实例呢？</p>\n<p>三、构造函数的静态属性缓存实例</p>\n<p>先看代码</p>\n<pre class=\"prettyprint\"><code>function Person(){ \n &#x2F;&#x2F;如果已经缓存了实例，则直接返回缓存的实例 \n if(typeof Person.instance===&#x27;object&#x27;){ \n return Person.instance; \n } \n this.createTime=new Date(); \n &#x2F;&#x2F;缓存实例 \n Person.instance=this; \n return this; \n} \n</code></pre><p>从代码可以看到，第一次new时，if的条件返回false，会往下走，初始化对象，然后保存对象到Person.instance这个静态属性中。\n第二次new 时，if的条件返回true，直接返回Person.instance，不会再往下运行初始化的代码。所以不管new几次，返回的都是第一次创建的对象。</p>\n<p>这个方法的缺点和方法一的缺点一样，Person.instance也是公开属性，有可能会被修改。</p>\n<p>我们参考方法二，使用闭包来封装一个，也许就能解决该问题了</p>\n<p>四、重写构造函数</p>\n<p>这个方法要使用闭包，但不能像方法二那么简单，我们需要重写构造函数。</p>\n<pre class=\"prettyprint\"><code>function Person(){ \n &#x2F;&#x2F;缓存实例 \n var instance=this; \n this.createTime=new Date(); \n &#x2F;&#x2F;重写构造函数 \n Person=function(){ \n return instance; \n } \n} \n</code></pre><p>第一次new 时，调用原始构造函数先缓存该实例，然后再初始化，同时，重写该构造函数。以后再new 时，永远调用不到原始的构造函数了，只能调用到重写后的构造函数，而这个函数总是返回缓存的instance.\n上面的方法似乎没什么问题，但通过下面的测试，可以发现问题</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;向原型添加属性 \nPerson.prototype.prop1=true; \nvar p1=new Person(); \n&#x2F;&#x2F;在创建初始化对象后，再次向该原型添加属性 \nPerson.prototype.prop2=true; \nvar p2=new Person(); \n\n&#x2F;&#x2F;开始测试 \nconsole.log(p1.prop1);&#x2F;&#x2F;结果为true \nconsole.log(p2.prop1);&#x2F;&#x2F;结果为true \n\nconsole.log(p1.prop2);&#x2F;&#x2F;结果为undefined \nconsole.log(p2.prop2);&#x2F;&#x2F;结果为undefined \n\nconsole.log(p1.constructor===Person);&#x2F;&#x2F;结果为false \nconsole.log(p2.constructor===Person);&#x2F;&#x2F;结果为false \n</code></pre><p>我们预期中的结果，应该是全都是true。\n分析一下上述测试代码</p>\n<p>Person.prototype.prop1=true;是在原始构造函数的原型下增加了prop1这个属性，并赋值</p>\n<p>而在执行 var p1=new Person();之后，Person这个构造函数已经被重写了</p>\n<p>所以Person.prototype.prop2=true;是在新的原型下增加prop2这个属性</p>\n<p>var p2=new Person(); p2和p1实际上是同一个对象，即原始构造函数创建的对象</p>\n<p>所以p1 p2都有prop1这个属性，而没有prop2这个属性</p>\n<p>同样的，p1 p2的constructor指向的也是原始的构造函数，而Person此时已不是原来那个函数了</p>\n<p>为了能按预期的结果那样运行，可以通过一些修改来实现</p>\n<pre class=\"prettyprint\"><code>function Person(){ \n &#x2F;&#x2F;缓存实例 \n var instance=this; \n &#x2F;&#x2F;重写构造函数 \n Person=function(){ \n return instance; \n } \n &#x2F;&#x2F;保留原型属性 \n Person.prototype=this; \n &#x2F;&#x2F;实例 \n instance=new Person(); \n &#x2F;&#x2F;重置构造函数引用 \n instance.constructor=Person; \n\n &#x2F;&#x2F;其他初始化 \n instance.createTime=new Date(); \n \n return instance; \n} \n</code></pre><p>再运行前面的测试代码，结果都是true了。</p>\n<p>原文链接：<a href=\"http://blog.csdn.net/bluestarjava/article/details/9967527\">http://blog.csdn.net/bluestarjava/article/details/9967527</a></p>\n</div>",
"title": "javascript单例模式",
"last_reply_at": "2016-08-01T12:35:49.217Z",
"good": false,
"top": false,
"reply_count": 4,
"visit_count": 3187,
"create_at": "2013-08-16T06:24:24.097Z",
"author": {
"loginname": "luojianjava",
"avatar_url": "//gravatar.com/avatar/e3e4e6a270cc04ccfd618bb9d72efe34?size=48"
}
},
{
"id": "579f21a6da05b9e92af325ec",
"author_id": "568a19253b33070b66270882",
"tab": "job",
"content": "<div class=\"markdown-text\"><p>职位: 前端高级工程师\n到岗时间：越快越好\n职责：负责公司产品的前端开发</p>\n<p>任职要求</p>\n<p>1 、熟练掌握 HTML 、 CSS 、 JS 。\n2 、熟练掌握 jQuery 、 AngularJS 等，熟悉 React 可加分。\n3 、熟悉 node.js 及 express,<a href=\"http://socket.io\">socket.io</a> 等。\n4 、熟悉页面性能优化及调试工具使用。</p>\n<p>加分项</p>\n<p>有 Github 作品或贡献过开源项目\n对交互设计有理解\n有在线教育类项目前端开发经验</p>\n<p>关于我们</p>\n<p>公司专注于打造针对国际学校的一站式教育服务平台，帮助国际学校提供课程系统，给国际学校学生提供mooc系统, 更专业的在线辅导，国外大学申请，游学等服务。</p>\n<p>公司老总线下有3所校区, 大约1000学生左右, 内容合伙人之前为精锐国际学校副校长, 技术合伙人为阿里巴巴, 百度和携程出身.</p>\n<p>我们提供:\n每天下午水果,\n每周两次羽毛球等球类活动,\n每周至少2次以上聚餐.\n买书报销,\nMBP\n机械键盘\n可观的股权</p>\n<p>联系我\n<a href=\"mailto:jiwengang@qingmiaoer.com\">jiwengang@qingmiaoer.com</a></p>\n</div>",
"title": "[上海浦东新区]高薪诚聘前端leader, 20-30k月薪加股权",
"last_reply_at": "2016-08-01T10:17:10.482Z",
"good": false,
"top": false,
"reply_count": 0,
"visit_count": 123,
"create_at": "2016-08-01T10:17:10.482Z",
"author": {
"loginname": "jeffreyji666",
"avatar_url": "https://avatars.githubusercontent.com/u/2270558?v=3&s=120"
}
},
{
"id": "579f019723e454cd2af8180c",
"author_id": "578c7c7b6d3f2b2014113f3f",
"tab": "ask",
"content": "<div class=\"markdown-text\"><p>似乎在issue有人问了关于phantomjs打包的问题，似乎是可以打包的，但是网上又没有相关的资料，又有人说electron不支持phantomjs的支持环境。现在就是有两问题；\n1.phantomjs作为入口文件可以打包吗？\n2.phantomjs作为nodejs的child_process执行，可以打包吗？</p>\n</div>",
"title": "Electron可以打包非nodejs代码么，比如phantomjs",
"last_reply_at": "2016-08-01T09:22:32.877Z",
"good": false,
"top": false,
"reply_count": 6,
"visit_count": 136,
"create_at": "2016-08-01T08:00:23.625Z",
"author": {
"loginname": "Cherokeeli",
"avatar_url": "https://avatars.githubusercontent.com/u/17857090?v=3&s=120"
}
}
]
}
